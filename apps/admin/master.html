<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>設定/回復（Master / 運用OS）</title>
    <link rel="stylesheet" href="/admin/assets/admin.css" />
  </head>
  <body>
    <div class="container">
      <div class="card-nav">
      <a class="card" href="/admin/ops">
        <div class="card-title">運用判断支援（Ops）</div>
        <div class="card-purpose">運用判断を安全に確定し、証跡を確認する。</div>
      </a>
      <a class="card" href="/admin/composer">
        <div class="card-title">通知作成（Composer）</div>
        <div class="card-purpose">通知を作成・承認し、送信計画を安全に実行する。</div>
      </a>
      <a class="card" href="/admin/monitor">
        <div class="card-title">配信結果（Monitor）</div>
        <div class="card-purpose">配信反応と健康状態を把握し、異常を見逃さない。</div>
      </a>
      <a class="card" href="/admin/errors">
        <div class="card-title">エラー一覧（Errors）</div>
        <div class="card-purpose">WARN/Retryなどのエラーを素早く確認する。</div>
      </a>
      <a class="card card-active" href="/admin/master">
        <div class="card-title">設定/回復（Master）</div>
        <div class="card-purpose">運用設定と回復操作を安全に実行する。</div>
      </a>
      <a class="card" href="/admin/read-model">
        <div class="card-title">通知集計（Read Model）</div>
        <div class="card-purpose">通知集計を参照し、判断材料を得る。</div>
      </a>
      <a class="card" href="/admin/review">
        <div class="card-title">運用レビュー記録（Review）</div>
        <div class="card-purpose">運用レビュー記録を残す。</div>
      </a>
      <a class="card" href="/admin/login">
        <div class="card-title">Admin Login</div>
        <div class="card-purpose">管理トークンで認証する。</div>
      </a>
      </div>

      <h1>設定/回復（Master / 運用OS）</h1>
      <div class="summary-header">
        <div class="summary-items"><span class="summary-label">見るべき3点</span><span>テンプレ / リンク / システム設定</span></div>
        <div class="summary-help"><span class="summary-label">迷ったら</span><span>Plan → 確認トークンの順で進める</span></div>
        <div class="summary-risk"><span class="summary-label">よくある失敗</span><span>planなしでsetを押す</span></div>
      </div>
      <div class="layout section">
        <div class="layout-left panel-stack">
          <div id="master-status-panel" class="panel panel-status status-card status-unknown">
            <div class="panel-title">状態サマリー</div>
            <div class="panel-body">
              <span id="master-status-pill" class="status-pill status-unknown">未取得</span>
              <span class="status-legend">赤=要対応 / 黄=注意 / 緑=問題なし / 灰=未設定/不明</span>
              <div class="status-meta">直近の設定操作結果（plan/set/回復）</div>
              <div class="status-focus">
                <span>今日の要対応</span>
                <span id="master-action-count" class="action-count">0</span>
              </div>
            </div>
          </div>
        </div>
        <div class="layout-right">
          <div class="action-panel panel-actions">
      <div class="panel-title">操作パネル</div>
      <div class="panel-body">
        <div class="note">テンプレとリンクを安全に管理します。</div>

        <div class="note">
          <span data-tip="traceId" tabindex="0">追跡ID</span>:
          <input type="text" id="traceId" class="input-inline input-trace" />
          <button id="regen-trace" type="button">regen</button>
          <span id="trace-note"></span>
        </div>
        <div id="master-skeleton" class="skeleton-stack is-hidden">
          <div class="skeleton-line lg w-50"></div>
          <div class="skeleton-line w-70"></div>
          <div class="skeleton-line w-30"></div>
        </div>

        <div class="grid">
      <div>
        <h2 data-tip="API: /api/phase61/templates" tabindex="0">通知テンプレ</h2>
        <div class="note">
          status:
          <select id="tpl-status" class="select-inline">
            <option value="">(全て)</option>
            <option value="draft">下書き</option>
            <option value="active">有効</option>
            <option value="inactive">停止</option>
          </select>
          <button id="tpl-reload" type="button">更新</button>
        </div>
        <details class="table-section" open>
          <summary>通知テンプレ</summary>
          <table class="table-compact">
            <thead>
              <tr>
                <th data-tip="key" tabindex="0">キー</th>
                <th data-tip="status" tabindex="0">状態</th>
                <th data-tip="notificationCategory" tabindex="0">カテゴリ</th>
                <th data-tip="title" tabindex="0">タイトル</th>
                <th>操作</th>
              </tr>
            </thead>
            <tbody id="tpl-rows"></tbody>
          </table>
        </details>

        <h3>テンプレ作成</h3>
        <label data-tip="key" tabindex="0">キー</label>
        <input id="tpl-key" placeholder="ops_escalate" />
        <label data-tip="title" tabindex="0">タイトル</label>
        <input id="tpl-title" />
        <label data-tip="notificationCategory" tabindex="0">カテゴリ</label>
        <select id="tpl-category">
          <option value="DEADLINE_REQUIRED">DEADLINE_REQUIRED</option>
          <option value="IMMEDIATE_ACTION">IMMEDIATE_ACTION</option>
          <option value="SEQUENCE_GUIDANCE" selected>SEQUENCE_GUIDANCE</option>
          <option value="TARGETED_ONLY">TARGETED_ONLY</option>
          <option value="COMPLETION_CONFIRMATION">COMPLETION_CONFIRMATION</option>
        </select>
        <label data-tip="body" tabindex="0">本文</label>
        <textarea id="tpl-text"></textarea>
        <button id="tpl-create" type="button">作成</button>
        <pre id="tpl-result">-</pre>
      </div>

      <div>
        <h2 data-tip="API: /admin/link-registry" tabindex="0">リンク管理</h2>
        <div class="note">
          state:
          <select id="link-state" class="select-inline">
            <option value="">(all)</option>
            <option value="OK">OK</option>
            <option value="WARN">WARN</option>
          </select>
          <button id="link-reload" type="button">更新</button>
        </div>
        <details class="table-section" open>
          <summary>リンク管理</summary>
          <table class="table-compact">
            <thead>
              <tr>
                <th data-tip="id" tabindex="0">ID</th>
                <th data-tip="title" tabindex="0">タイトル</th>
                <th data-tip="url" tabindex="0">リンク先</th>
                <th data-tip="state" tabindex="0">状態</th>
              </tr>
            </thead>
            <tbody id="link-rows"></tbody>
          </table>
        </details>

        <h3>Create Link</h3>
        <label>title</label>
        <input id="link-title" />
        <label>url</label>
        <input id="link-url" placeholder="https://..." />
        <button id="link-create" type="button">create</button>
        <pre id="link-result">-</pre>
      </div>
    </div>

    <hr />

    <h2>Redacクラブ会員ID（例外解除）</h2>
    <div class="note">
      重複拒否（B）の運用で詰まった場合のみ使用。入力した会員ID全文は保存しない（HMAC hash + last4のみ）。
      誰に紐付いているかは「解除結果」でのみ返る（運用者向け）。
    </div>
    <label data-tip="redacMembershipId" tabindex="0">会員ID（例: 00-0000）</label>
    <input id="redac-unlink-id" placeholder="00-0000" />
    <button id="redac-unlink" type="button">解除</button>
    <pre id="redac-unlink-result">-</pre>

    <hr />

    <h2>Redac運用確認</h2>
    <div class="note">
      Redac運用の整合性を確認します（secret設定や不整合の検出）。
    </div>
    <div class="note">
      <button id="redac-health-reload" type="button">更新</button>
    </div>
    <pre id="redac-health-result">-</pre>

    <hr />

    <h2>システム設定（SSOT）</h2>
    <div class="note">設定変更は計画 → 確認トークン → 適用の順で行います。</div>
    <div class="note">
      <button id="config-reload" type="button">更新</button>
    </div>
    <pre id="config-status">-</pre>
    <h3>LLM提案機能（FAQ/Ops/NextAction）</h3>
    <div class="note">提案機能の停止/再開のみを行います（送信停止killSwitchとは別機能）。</div>
    <label data-tip="llmEnabled" tabindex="0">LLM提案機能</label>
    <select id="llm-config-enabled">
      <option value="false">停止</option>
      <option value="true">有効</option>
    </select>
    <div class="note">
      <button id="llm-config-reload" type="button">更新</button>
      <button id="llm-config-plan" type="button">計画</button>
      <button id="llm-config-set" type="button">適用</button>
    </div>
    <pre id="llm-config-status">-</pre>
    <pre id="llm-config-plan-result">-</pre>
    <pre id="llm-config-set-result">-</pre>
    <h3>LLM FAQ 検証（管理者）</h3>
    <div class="note">KB候補が無い場合や根拠不足の場合は回答を出さずに停止します。</div>
    <label data-tip="question" tabindex="0">質問</label>
    <textarea id="llm-faq-question" placeholder="例: 会員番号の確認方法を教えて"></textarea>
    <label data-tip="locale" tabindex="0">言語</label>
    <select id="llm-faq-locale">
      <option value="ja">ja</option>
      <option value="en">en</option>
    </select>
    <label data-tip="intent" tabindex="0">意図（任意）</label>
    <input id="llm-faq-intent" placeholder="例: membership_verify" />
    <div class="note">
      <button id="llm-faq-answer" type="button">FAQ回答を生成</button>
    </div>
    <pre id="llm-faq-result">-</pre>
    <h3>LLM Ops説明 / 次アクション候補（管理者）</h3>
    <div class="note">lineUserId を指定して説明と候補を確認します（提案のみ、自動実行なし）。</div>
    <label data-tip="lineUserId" tabindex="0">LINEユーザーID</label>
    <input id="llm-ops-line-user-id" placeholder="Uxxxxxxxx" />
    <div class="note">
      <button id="llm-ops-explain" type="button">Ops説明を取得</button>
      <button id="llm-next-actions" type="button">次候補を取得</button>
    </div>
    <pre id="llm-ops-explain-result">-</pre>
    <pre id="llm-next-actions-result">-</pre>

        </div>
      </div>
      <div>
        <label data-tip="servicePhase" tabindex="0">サービスフェーズ（未設定で解除）</label>
        <select id="config-service-phase">
          <option value="">(null)</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
        </select>
      </div>
      <div>
        <label data-tip="notificationPreset" tabindex="0">通知プリセット（未設定で解除）</label>
        <select id="config-notification-preset">
          <option value="">(null)</option>
          <option value="A">A</option>
          <option value="B">B</option>
          <option value="C">C</option>
        </select>
      </div>
      <div>
        <label data-tip="notificationCaps.perUserWeeklyCap" tabindex="0">週あたり上限（ユーザー）</label>
        <input id="config-notification-cap-weekly" placeholder="(未設定 or 数値)" />
      </div>
      <div>
        <label data-tip="notificationCaps.perUserDailyCap" tabindex="0">日あたり上限（ユーザー）</label>
        <input id="config-notification-cap-daily" placeholder="(未設定 or 数値)" />
      </div>
      <div>
        <label data-tip="notificationCaps.perCategoryWeeklyCap" tabindex="0">週あたり上限（カテゴリ）</label>
        <input id="config-notification-cap-category-weekly" placeholder="(未設定 or 数値)" />
      </div>
      <div>
        <label data-tip="notificationCaps.quietHours.startHourUtc" tabindex="0">静穏時間（開始 UTC）</label>
        <input id="config-notification-quiet-start" placeholder="0-23" />
      </div>
      <div>
        <label data-tip="notificationCaps.quietHours.endHourUtc" tabindex="0">静穏時間（終了 UTC）</label>
        <input id="config-notification-quiet-end" placeholder="0-23" />
      </div>
      <div>
        <label data-tip="deliveryCountLegacyFallback" tabindex="0">配信集計の互換モード</label>
        <select id="config-delivery-count-legacy-fallback">
          <option value="true">true</option>
          <option value="false">false</option>
        </select>
      </div>
    </div>
    <div class="note">
      <button id="config-plan" type="button">計画</button>
      <button id="config-set" type="button">適用</button>
    </div>
    <pre id="config-plan-result">-</pre>
    <pre id="config-impact-preview">-</pre>
    <pre id="config-set-result">-</pre>

    <hr />

    <h2>自動化設定（実行ガード）</h2>
    <div class="note">変更は計画 → 確認トークン → 適用の順で行います。</div>
    <div class="note">
      <button id="automation-config-reload" type="button">更新</button>
    </div>
    <pre id="automation-config-status">-</pre>
    <label data-tip="mode" tabindex="0">実行モード</label>
    <select id="automation-config-mode">
      <option value="OFF">停止</option>
      <option value="DRY_RUN_ONLY">検証のみ</option>
      <option value="EXECUTE">実行</option>
    </select>
    <div class="note">
      <button id="automation-config-plan" type="button">計画</button>
      <button id="automation-config-set" type="button">適用</button>
    </div>
    <pre id="automation-config-plan-result">-</pre>
    <pre id="automation-config-set-result">-</pre>

    <hr />

    <h2>配信回復（封印）</h2>
    <div class="note">
      送信前に停止した配信を「封印」して回復処理を完了扱いにします（再送しません）。
    </div>
    <label data-tip="deliveryId" tabindex="0">配信ID</label>
    <input id="delivery-recovery-id" placeholder="delivery id" />
    <label data-tip="sealedReason" tabindex="0">封印理由（任意）</label>
    <input id="delivery-recovery-reason" placeholder="manual_recovery" />
    <div class="note">
      <button id="delivery-recovery-status" type="button">状況確認</button>
      <button id="delivery-recovery-plan" type="button">計画</button>
      <button id="delivery-recovery-execute" type="button">封印実行</button>
    </div>
    <pre id="delivery-recovery-status-result">-</pre>
    <pre id="delivery-recovery-recommendation">-</pre>
    <pre id="delivery-recovery-plan-result">-</pre>
    <pre id="delivery-recovery-execute-result">-</pre>

    <hr />

    <h2>配信補正（deliveredAt）</h2>
    <div class="note">
      過去データの不足を補正します。計画 → 確認トークン → 実行の順で行います。
    </div>
    <label data-tip="limit" tabindex="0">件数（1-1000）</label>
    <input id="delivery-backfill-limit" placeholder="200" />
    <div class="note">
      <button id="delivery-backfill-status" type="button">状況確認</button>
      <button id="delivery-backfill-plan" type="button">計画</button>
      <button id="delivery-backfill-execute" type="button">補正実行</button>
    </div>
    <pre id="delivery-backfill-status-result">-</pre>
    <pre id="delivery-backfill-plan-result">-</pre>
    <pre id="delivery-backfill-execute-result">-</pre>

      </div>
    </div>
    </div>
  </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>
    <script>
      const ACTOR_HEADERS = { 'x-actor': 'admin_master' };
      const TRACE_HEADER_NAME = 'x-trace-id';
      let configPlanHash = null;
      let configConfirmToken = null;
      let llmPlanHash = null;
      let llmConfirmToken = null;
      let automationPlanHash = null;
      let automationConfirmToken = null;
      let deliveryRecoveryPlanHash = null;
      let deliveryRecoveryConfirmToken = null;
      let deliveryBackfillPlanHash = null;
      let deliveryBackfillConfirmToken = null;
      const toastEl = document.getElementById('toast');
      const skeletonEl = document.getElementById('master-skeleton');
      const statusPanelEl = document.getElementById('master-status-panel');
      const actionCountEl = document.getElementById('master-action-count');
      const statusPillEl = document.getElementById('master-status-pill');

      function newTraceId() {
        if (globalThis.crypto && typeof globalThis.crypto.randomUUID === 'function') {
          return globalThis.crypto.randomUUID();
        }
        return `trace-${Date.now()}-${Math.floor(Math.random() * 1e9)}`;
      }

      function getTraceId() {
        const el = document.getElementById('traceId');
        const value = el.value.trim();
        return value.length ? value : null;
      }

      function setTraceId(value) {
        const el = document.getElementById('traceId');
        el.value = value || '';
      }

      function ensureTraceId() {
        const value = getTraceId();
        if (value) return value;
        const next = newTraceId();
        setTraceId(next);
        return next;
      }

      function buildHeaders(extra) {
        const traceId = ensureTraceId();
        return Object.assign({}, extra || {}, ACTOR_HEADERS, { [TRACE_HEADER_NAME]: traceId });
      }

      document.getElementById('regen-trace').addEventListener('click', () => {
        setTraceId(newTraceId());
        document.getElementById('trace-note').textContent = '';
      });

      setTraceId(newTraceId());
      if (actionCountEl) actionCountEl.textContent = '0';

      // Best-effort view audit (do not block UI).
      (async () => {
        try {
          const traceId = ensureTraceId();
          await fetch('/api/admin/os/view', {
            method: 'POST',
            headers: Object.assign({ 'content-type': 'application/json; charset=utf-8', [TRACE_HEADER_NAME]: traceId }, ACTOR_HEADERS),
            body: JSON.stringify({ screen: 'master' })
          });
        } catch (_err) {}
      })();

      function clearChildren(el) {
        while (el.firstChild) el.removeChild(el.firstChild);
      }

      function appendMessageRow(tbody, colSpan, message) {
        clearChildren(tbody);
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = colSpan;
        td.textContent = message;
        tr.appendChild(td);
        tbody.appendChild(tr);
      }

      function appendRow(tbody, values) {
        const tr = document.createElement('tr');
        for (const value of values) {
          const td = document.createElement('td');
          if (value instanceof Node) {
            td.appendChild(value);
          } else {
            td.textContent = value === null || value === undefined ? '-' : String(value);
          }
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }

      function jsonOrText(res) {
        return res.text().then((text) => {
          try { return JSON.parse(text); } catch (_err) { return { ok: false, error: text || 'error' }; }
        });
      }

      async function fetchJsonWithFallback(primaryPath, fallbackPath) {
        try {
          const primaryRes = await fetch(primaryPath, { headers: buildHeaders() });
          if (primaryRes.status !== 404) {
            return await jsonOrText(primaryRes);
          }
        } catch (_err) {}
        const fallbackRes = await fetch(fallbackPath, { headers: buildHeaders() });
        return await jsonOrText(fallbackRes);
      }

      function showToast(message, tone) {
        if (!toastEl) return;
        toastEl.textContent = message;
        toastEl.className = `toast ${tone || ''} show`;
        setTimeout(() => {
          toastEl.className = 'toast';
          toastEl.textContent = '';
        }, 2200);
      }

      function toastByResult(label, result) {
        const ok = result === true || (result && typeof result === 'object' && result.ok);
        showToast(`${label} ${ok ? 'OK' : '失敗'}`, ok ? 'ok' : 'danger');
        return ok;
      }

      function setLoading(isLoading) {
        if (!skeletonEl) return;
        skeletonEl.classList.toggle('is-hidden', !isLoading);
      }

      function setStatusTone(tone) {
        if (!statusPanelEl) return;
        statusPanelEl.classList.remove('status-ok', 'status-warn', 'status-danger', 'status-unknown');
        statusPanelEl.classList.add(`status-${tone || 'unknown'}`);
        if (statusPillEl) {
          const nextTone = tone || 'unknown';
          statusPillEl.className = `status-pill status-${nextTone}`;
          if (nextTone === 'ok') statusPillEl.textContent = 'OK';
          else if (nextTone === 'warn') statusPillEl.textContent = 'WARN';
          else if (nextTone === 'danger') statusPillEl.textContent = 'DANGER';
          else statusPillEl.textContent = '未取得';
        }
      }

      function applyHeaderTooltips() {
        document.querySelectorAll('th').forEach((th) => {
          const text = (th.textContent || '').trim();
          if (text && !th.dataset.tip) {
            th.dataset.tip = text;
            th.setAttribute('tabindex', '0');
          }
        });
      }

      function applyInputTooltips() {
        document.querySelectorAll('input, select, textarea').forEach((el) => {
          if (el.id && !el.dataset.tip) {
            el.dataset.tip = el.id;
          }
        });
      }

      function runWithToast(label, fn) {
        setLoading(true);
        return fn()
          .then((result) => {
            const ok = toastByResult(label, result);
            setStatusTone(ok ? 'ok' : 'danger');
            return result;
          })
          .catch((err) => {
            showToast(`${label} 失敗`, 'danger');
            setStatusTone('danger');
            throw err;
          })
          .finally(() => {
            setLoading(false);
          });
      }

      function sortedEntries(obj) {
        return Object.entries(obj || {}).sort((a, b) => {
          if (a[0] === b[0]) return 0;
          return a[0] > b[0] ? 1 : -1;
        });
      }

      function formatBreakdownRows(label, rows) {
        const list = Array.isArray(rows) ? rows : [];
        if (!list.length) return [];
        const lines = [`${label}:`];
        for (const row of list) {
          if (!row || typeof row !== 'object') continue;
          const key = row.key || '-';
          const count = Number.isFinite(row.count) ? row.count : 0;
          const ratePercent = Number.isFinite(row.ratePercent) ? row.ratePercent : 0;
          lines.push(`- ${key}: ${count} (${ratePercent}%)`);
        }
        return lines;
      }

      function formatImpactPreview(preview) {
        if (!preview || typeof preview !== 'object') return 'impact preview unavailable';
        const sampledUsers = Number.isFinite(preview.sampledUsers) ? preview.sampledUsers : 0;
        const sampledEvaluations = Number.isFinite(preview.sampledEvaluations) ? preview.sampledEvaluations : sampledUsers;
        const blockedEvaluations = Number.isFinite(preview.blockedEvaluations) ? preview.blockedEvaluations : 0;
        const estimatedBlockedUsers = Number.isFinite(preview.estimatedBlockedUsers) ? preview.estimatedBlockedUsers : 0;
        const estimatedBlockedUserRatePercent = Number.isFinite(preview.estimatedBlockedUserRatePercent)
          ? preview.estimatedBlockedUserRatePercent
          : 0;
        const blockedEvaluationRatePercent = Number.isFinite(preview.blockedEvaluationRatePercent)
          ? preview.blockedEvaluationRatePercent
          : 0;
        const topBlockedCapType = preview.topBlockedCapType ? String(preview.topBlockedCapType) : '(none)';
        const topBlockedCategory = preview.topBlockedCategory ? String(preview.topBlockedCategory) : '(none)';
        const blockedByCapType = sortedEntries(preview.blockedByCapType);
        const blockedByCategory = sortedEntries(preview.blockedByCategory);
        const blockedByReason = sortedEntries(preview.blockedByReason);
        const categories = Array.isArray(preview.simulatedCategories) ? preview.simulatedCategories : [];
        const notes = Array.isArray(preview.notes) ? preview.notes : [];
        const riskLevel = preview.riskLevel ? String(preview.riskLevel) : 'UNKNOWN';
        const recommendedAction = preview.recommendedAction ? String(preview.recommendedAction) : 'REVIEW_BEFORE_SET';
        const lines = [
          `sampledUsers: ${sampledUsers}`,
          `sampledEvaluations: ${sampledEvaluations}`,
          `blockedEvaluations: ${blockedEvaluations}`,
          `blockedEvaluationRatePercent: ${blockedEvaluationRatePercent}`,
          `estimatedBlockedUsers: ${estimatedBlockedUsers}`,
          `estimatedBlockedUserRatePercent: ${estimatedBlockedUserRatePercent}`,
          `riskLevel: ${riskLevel}`,
          `recommendedAction: ${recommendedAction}`,
          `topBlockedCapType: ${topBlockedCapType}`,
          `topBlockedCategory: ${topBlockedCategory}`,
          `simulatedCategories: ${categories.length ? categories.join(', ') : '(none)'}`
        ];
        const capTypeBreakdown = formatBreakdownRows('capTypeBreakdown', preview.capTypeBreakdown);
        const reasonBreakdown = formatBreakdownRows('reasonBreakdown', preview.reasonBreakdown);
        const categoryBreakdown = formatBreakdownRows('categoryBreakdown', preview.categoryBreakdown);
        lines.push(...capTypeBreakdown);
        lines.push(...reasonBreakdown);
        lines.push(...categoryBreakdown);
        if (blockedByCapType.length) {
          lines.push('blockedByCapType:');
          for (const [k, v] of blockedByCapType) lines.push(`- ${k}: ${v}`);
        }
        if (blockedByCategory.length) {
          lines.push('blockedByCategory:');
          for (const [k, v] of blockedByCategory) lines.push(`- ${k}: ${v}`);
        }
        if (blockedByReason.length) {
          lines.push('blockedByReason:');
          for (const [k, v] of blockedByReason) lines.push(`- ${k}: ${v}`);
        }
        if (notes.length) {
          lines.push('notes:');
          for (const note of notes) lines.push(`- ${String(note)}`);
        }
        return lines.join('\n');
      }

      function formatDeliveryRecoveryRecommendation(recovery) {
        const payload = recovery && typeof recovery === 'object' ? recovery : {};
        const recommendedAction = payload.recommendedAction ? String(payload.recommendedAction) : 'INSPECT';
        const allowedActions = Array.isArray(payload.allowedActions) ? payload.allowedActions : [];
        const retryPossible = payload.retryPossible === true;
        const canSeal = payload.canSeal === true;
        const lines = [
          `recommendedAction: ${recommendedAction}`,
          `allowedActions: ${allowedActions.length ? allowedActions.join(', ') : '(none)'}`,
          `retryPossible: ${retryPossible ? 'yes' : 'no'}`,
          `canSeal: ${canSeal ? 'yes' : 'no'}`
        ];
        lines.push('guide:');
        if (recommendedAction === 'NO_ACTION') {
          lines.push('- this delivery is already settled. no operation is required.');
        } else if (recommendedAction === 'RETRY_OR_SEAL') {
          lines.push('- retry first if cause is recoverable; use seal only when retry is not appropriate.');
        } else if (recommendedAction === 'SEAL') {
          lines.push('- use seal to close stuck reserved/in-flight records and avoid duplicate delivery.');
        } else {
          lines.push('- inspect audit/trace first, then choose action.');
        }
        return lines.join('\n');
      }

      async function loadTemplates() {
        const status = document.getElementById('tpl-status').value;
        const params = new URLSearchParams();
        if (status) params.set('status', status);
        const res = await fetch(`/api/phase61/templates${params.toString() ? `?${params.toString()}` : ''}`, { headers: buildHeaders() });
        const data = await res.json();
        const rows = document.getElementById('tpl-rows');
        if (!data.ok) {
          appendMessageRow(rows, 5, '取得失敗');
          return data;
        }
        const items = Array.isArray(data.items) ? data.items : [];
        if (!items.length) {
          appendMessageRow(rows, 5, 'no data');
          return data;
        }
        clearChildren(rows);
        for (const item of items) {
          const actions = document.createElement('span');

          const activateBtn = document.createElement('button');
          activateBtn.type = 'button';
          activateBtn.textContent = 'activate';
          activateBtn.addEventListener('click', async () => {
            const key = item && item.key ? String(item.key) : '';
            if (!key) return;
            const res2 = await fetch(`/api/phase61/templates/${encodeURIComponent(key)}/activate`, {
              method: 'POST',
              headers: buildHeaders()
            });
            document.getElementById('tpl-result').textContent = JSON.stringify(await res2.json(), null, 2);
            await loadTemplates();
          });
          actions.appendChild(activateBtn);

          const space = document.createTextNode(' ');
          actions.appendChild(space);

          const deactivateBtn = document.createElement('button');
          deactivateBtn.type = 'button';
          deactivateBtn.textContent = 'deactivate';
          deactivateBtn.addEventListener('click', async () => {
            const key = item && item.key ? String(item.key) : '';
            if (!key) return;
            const res2 = await fetch(`/api/phase61/templates/${encodeURIComponent(key)}/deactivate`, {
              method: 'POST',
              headers: buildHeaders()
            });
            document.getElementById('tpl-result').textContent = JSON.stringify(await res2.json(), null, 2);
            await loadTemplates();
          });
          actions.appendChild(deactivateBtn);

          appendRow(rows, [
            item.key || '-',
            item.status || '-',
            item.notificationCategory || '-',
            item.title || '-',
            actions
          ]);
        }
        return data;
      }

      async function createTemplate() {
        const payload = {
          key: document.getElementById('tpl-key').value.trim(),
          title: document.getElementById('tpl-title').value.trim(),
          notificationCategory: document.getElementById('tpl-category').value,
          text: document.getElementById('tpl-text').value
        };
        const res = await fetch('/api/phase61/templates', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        document.getElementById('tpl-result').textContent = JSON.stringify(data, null, 2);
        await loadTemplates();
        return data;
      }

      async function loadLinks() {
        const state = document.getElementById('link-state').value;
        const params = new URLSearchParams();
        if (state) params.set('state', state);
        const res = await fetch(`/admin/link-registry${params.toString() ? `?${params.toString()}` : ''}`, { headers: buildHeaders() });
        const data = await res.json();
        const rows = document.getElementById('link-rows');
        if (!data.ok) {
          appendMessageRow(rows, 4, '取得失敗');
          return data;
        }
        const items = Array.isArray(data.items) ? data.items : [];
        if (!items.length) {
          appendMessageRow(rows, 4, 'no data');
          return data;
        }
        clearChildren(rows);
        for (const item of items) {
          appendRow(rows, [
            item.id || '-',
            item.title || '-',
            item.url || '-',
            item.lastHealth && item.lastHealth.state ? item.lastHealth.state : '-'
          ]);
        }
        return data;
      }

      async function createLink() {
        const payload = {
          title: document.getElementById('link-title').value.trim(),
          url: document.getElementById('link-url').value.trim()
        };
        const res = await fetch('/admin/link-registry', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(payload)
        });
        const data = await jsonOrText(res);
        document.getElementById('link-result').textContent = JSON.stringify(data, null, 2);
        await loadLinks();
        return data;
      }

      async function unlinkRedacMembership() {
        const redacMembershipId = document.getElementById('redac-unlink-id').value.trim();
        if (!redacMembershipId) return { ok: false, error: '会員IDが必要です' };
        const ok = window.confirm(`Redac会員IDを解除しますか？\n\n${redacMembershipId}\n\n(例外対応: 通常は使いません)`); // eslint-disable-line no-alert
        if (!ok) return { ok: false, error: 'キャンセルしました' };
        const res = await fetch('/api/admin/redac-membership/unlink', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({ redacMembershipId })
        });
        const data = await jsonOrText(res);
        document.getElementById('redac-unlink-result').textContent = JSON.stringify(data, null, 2);
        return data;
      }

      async function loadRedacStatus() {
        const res = await fetch('/api/admin/os/redac/status?limit=500', {
          headers: buildHeaders()
        });
        const data = await jsonOrText(res);
        document.getElementById('redac-health-result').textContent = JSON.stringify(data, null, 2);
        return data;
      }

      function parseNullableInt(value) {
        const trimmed = String(value || '').trim();
        if (!trimmed) return null;
        const num = Number(trimmed);
        if (!Number.isInteger(num)) return null;
        return num;
      }

      function parseNullableString(value) {
        const trimmed = String(value || '').trim();
        return trimmed ? trimmed : null;
      }

      function parseNullablePositiveInt(value) {
        const trimmed = String(value || '').trim();
        if (!trimmed) return { ok: true, value: null };
        const num = Number(trimmed);
        if (!Number.isInteger(num) || num < 1) return { ok: false, error: '上限は正の整数または未設定です' };
        return { ok: true, value: num };
      }

      function parseNullableHour(value) {
        const trimmed = String(value || '').trim();
        if (!trimmed) return { ok: true, value: null };
        const num = Number(trimmed);
        if (!Number.isInteger(num) || num < 0 || num > 23) {
          return { ok: false, error: '静穏時間は0-23または未設定です' };
        }
        return { ok: true, value: num };
      }

      function readNotificationCapsFromForm() {
        const weekly = parseNullablePositiveInt(document.getElementById('config-notification-cap-weekly').value);
        if (!weekly.ok) return weekly;
        const daily = parseNullablePositiveInt(document.getElementById('config-notification-cap-daily').value);
        if (!daily.ok) return daily;
        const categoryWeekly = parseNullablePositiveInt(document.getElementById('config-notification-cap-category-weekly').value);
        if (!categoryWeekly.ok) return categoryWeekly;
        const quietStart = parseNullableHour(document.getElementById('config-notification-quiet-start').value);
        if (!quietStart.ok) return quietStart;
        const quietEnd = parseNullableHour(document.getElementById('config-notification-quiet-end').value);
        if (!quietEnd.ok) return quietEnd;

        let quietHours = null;
        if (quietStart.value !== null || quietEnd.value !== null) {
          if (quietStart.value === null || quietEnd.value === null) {
            return { ok: false, error: '開始/終了は両方設定または両方未設定です' };
          }
          quietHours = {
            startHourUtc: quietStart.value,
            endHourUtc: quietEnd.value
          };
        }
        return {
          ok: true,
          value: {
            perUserWeeklyCap: weekly.value,
            perUserDailyCap: daily.value,
            perCategoryWeeklyCap: categoryWeekly.value,
            quietHours
          }
        };
      }

      function parseDeliveryCountLegacyFallback(value) {
        return String(value || '').trim().toLowerCase() !== 'false';
      }

      function parseBackfillLimit(value) {
        const trimmed = String(value || '').trim();
        if (!trimmed) return { ok: true, value: 200 };
        const num = Number(trimmed);
        if (!Number.isInteger(num) || num < 1 || num > 1000) {
          return { ok: false, error: '件数は1-1000の整数です' };
        }
        return { ok: true, value: num };
      }

      function parseBooleanFlag(value) {
        return String(value || '').trim().toLowerCase() === 'true';
      }

      async function loadSystemConfigStatus() {
        const res = await fetch('/api/admin/os/config/status', { headers: buildHeaders() });
        const data = await jsonOrText(res);
        document.getElementById('config-status').textContent = JSON.stringify(data, null, 2);
        if (data && data.ok) {
          const sp = data.servicePhase === null || data.servicePhase === undefined ? '' : String(data.servicePhase);
          document.getElementById('config-service-phase').value = sp;
          const preset = data.notificationPreset ? String(data.notificationPreset) : '';
          document.getElementById('config-notification-preset').value = preset;
          const weeklyCap = data.notificationCaps && data.notificationCaps.perUserWeeklyCap !== null && data.notificationCaps.perUserWeeklyCap !== undefined
            ? String(data.notificationCaps.perUserWeeklyCap)
            : '';
          document.getElementById('config-notification-cap-weekly').value = weeklyCap;
          const dailyCap = data.notificationCaps && data.notificationCaps.perUserDailyCap !== null && data.notificationCaps.perUserDailyCap !== undefined
            ? String(data.notificationCaps.perUserDailyCap)
            : '';
          document.getElementById('config-notification-cap-daily').value = dailyCap;
          const categoryWeeklyCap = data.notificationCaps && data.notificationCaps.perCategoryWeeklyCap !== null && data.notificationCaps.perCategoryWeeklyCap !== undefined
            ? String(data.notificationCaps.perCategoryWeeklyCap)
            : '';
          document.getElementById('config-notification-cap-category-weekly').value = categoryWeeklyCap;
          const quietStart = data.notificationCaps && data.notificationCaps.quietHours && data.notificationCaps.quietHours.startHourUtc !== undefined
            ? String(data.notificationCaps.quietHours.startHourUtc)
            : '';
          const quietEnd = data.notificationCaps && data.notificationCaps.quietHours && data.notificationCaps.quietHours.endHourUtc !== undefined
            ? String(data.notificationCaps.quietHours.endHourUtc)
            : '';
          document.getElementById('config-notification-quiet-start').value = quietStart;
          document.getElementById('config-notification-quiet-end').value = quietEnd;
          const legacyFallback = data.deliveryCountLegacyFallback === false ? 'false' : 'true';
          document.getElementById('config-delivery-count-legacy-fallback').value = legacyFallback;
        }
        return data;
      }

      async function loadLlmConfigStatus() {
        const res = await fetch('/api/admin/llm/config/status', { headers: buildHeaders() });
        const data = await jsonOrText(res);
        document.getElementById('llm-config-status').textContent = JSON.stringify(data, null, 2);
        if (data && data.ok) {
          document.getElementById('llm-config-enabled').value = data.llmEnabled ? 'true' : 'false';
        }
        return data;
      }

      async function planLlmConfig() {
        const llmEnabled = parseBooleanFlag(document.getElementById('llm-config-enabled').value);
        const res = await fetch('/api/admin/llm/config/plan', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({ llmEnabled })
        });
        const data = await jsonOrText(res);
        document.getElementById('llm-config-plan-result').textContent = JSON.stringify(data, null, 2);
        llmPlanHash = data && data.ok ? data.planHash || null : null;
        llmConfirmToken = data && data.ok ? data.confirmToken || null : null;
        return data;
      }

      async function setLlmConfig() {
        const llmEnabled = parseBooleanFlag(document.getElementById('llm-config-enabled').value);
        if (!llmPlanHash || !llmConfirmToken) {
          document.getElementById('llm-config-set-result').textContent = JSON.stringify({ ok: false, error: '計画が必要です' }, null, 2);
          return { ok: false, error: '計画が必要です' };
        }
        const ok = window.confirm(`LLM提案機能を ${llmEnabled ? '有効' : '停止'} に設定しますか？`); // eslint-disable-line no-alert
        if (!ok) return { ok: false, error: 'キャンセルしました' };
        const res = await fetch('/api/admin/llm/config/set', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({
            llmEnabled,
            planHash: llmPlanHash,
            confirmToken: llmConfirmToken
          })
        });
        const data = await jsonOrText(res);
        document.getElementById('llm-config-set-result').textContent = JSON.stringify(data, null, 2);
        await loadLlmConfigStatus();
        return data;
      }

      async function generateLlmFaqAnswer() {
        const question = document.getElementById('llm-faq-question').value.trim();
        const locale = document.getElementById('llm-faq-locale').value;
        const intentRaw = document.getElementById('llm-faq-intent').value.trim();
        if (!question) {
          const err = { ok: false, error: '質問が必要です' };
          document.getElementById('llm-faq-result').textContent = JSON.stringify(err, null, 2);
          return err;
        }
        const payload = { question, locale };
        if (intentRaw) payload.intent = intentRaw;
        const res = await fetch('/api/admin/llm/faq/answer', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(payload)
        });
        const data = await jsonOrText(res);
        document.getElementById('llm-faq-result').textContent = JSON.stringify(data, null, 2);
        return data;
      }

      function getLlmOpsLineUserId() {
        return document.getElementById('llm-ops-line-user-id').value.trim();
      }

      async function fetchLlmOpsExplain() {
        const lineUserId = getLlmOpsLineUserId();
        if (!lineUserId) {
          const err = { ok: false, error: 'lineUserId が必要です' };
          document.getElementById('llm-ops-explain-result').textContent = JSON.stringify(err, null, 2);
          return err;
        }
        const qs = new URLSearchParams({ lineUserId });
        const data = await fetchJsonWithFallback(
          `/api/admin/llm/ops-explain?${qs.toString()}`,
          `/api/phaseLLM2/ops-explain?${qs.toString()}`
        );
        document.getElementById('llm-ops-explain-result').textContent = JSON.stringify(data, null, 2);
        return data;
      }

      async function fetchLlmNextActions() {
        const lineUserId = getLlmOpsLineUserId();
        if (!lineUserId) {
          const err = { ok: false, error: 'lineUserId が必要です' };
          document.getElementById('llm-next-actions-result').textContent = JSON.stringify(err, null, 2);
          return err;
        }
        const qs = new URLSearchParams({ lineUserId });
        const data = await fetchJsonWithFallback(
          `/api/admin/llm/next-actions?${qs.toString()}`,
          `/api/phaseLLM3/ops-next-actions?${qs.toString()}`
        );
        document.getElementById('llm-next-actions-result').textContent = JSON.stringify(data, null, 2);
        return data;
      }

      async function planSystemConfig() {
        const servicePhase = parseNullableInt(document.getElementById('config-service-phase').value);
        const notificationPreset = parseNullableString(document.getElementById('config-notification-preset').value);
        const capParsed = readNotificationCapsFromForm();
        if (!capParsed.ok) {
          document.getElementById('config-plan-result').textContent = JSON.stringify({ ok: false, error: capParsed.error }, null, 2);
          return { ok: false, error: capParsed.error };
        }
        const deliveryCountLegacyFallback = parseDeliveryCountLegacyFallback(
          document.getElementById('config-delivery-count-legacy-fallback').value
        );
        const notificationCaps = capParsed.value;
        const res = await fetch('/api/admin/os/config/plan', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({ servicePhase, notificationPreset, notificationCaps, deliveryCountLegacyFallback })
        });
        const data = await jsonOrText(res);
        document.getElementById('config-plan-result').textContent = JSON.stringify(data, null, 2);
        const impactPreview = data && data.impactPreview ? data.impactPreview : { ok: false, error: '影響プレビュー取得不可' };
        document.getElementById('config-impact-preview').textContent = `${formatImpactPreview(impactPreview)}\n\nraw:\n${JSON.stringify(impactPreview, null, 2)}`;
        configPlanHash = data && data.ok ? data.planHash || null : null;
        configConfirmToken = data && data.ok ? data.confirmToken || null : null;
        return data;
      }

      async function setSystemConfig() {
        const servicePhase = parseNullableInt(document.getElementById('config-service-phase').value);
        const notificationPreset = parseNullableString(document.getElementById('config-notification-preset').value);
        const capParsed = readNotificationCapsFromForm();
        if (!capParsed.ok) {
          document.getElementById('config-set-result').textContent = JSON.stringify({ ok: false, error: capParsed.error }, null, 2);
          return { ok: false, error: capParsed.error };
        }
        const deliveryCountLegacyFallback = parseDeliveryCountLegacyFallback(
          document.getElementById('config-delivery-count-legacy-fallback').value
        );
        const notificationCaps = capParsed.value;
        if (!configPlanHash || !configConfirmToken) {
          document.getElementById('config-set-result').textContent = JSON.stringify({ ok: false, error: '計画が必要です' }, null, 2);
          return { ok: false, error: '計画が必要です' };
        }
        const ok = window.confirm(`System Config を set しますか？\n\nservicePhase=${servicePhase === null ? 'null' : String(servicePhase)}\nnotificationPreset=${notificationPreset === null ? 'null' : String(notificationPreset)}\nnotificationCaps=${JSON.stringify(notificationCaps)}\ndeliveryCountLegacyFallback=${deliveryCountLegacyFallback}`); // eslint-disable-line no-alert
        if (!ok) return { ok: false, error: 'キャンセルしました' };
        const res = await fetch('/api/admin/os/config/set', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({
            servicePhase,
            notificationPreset,
            notificationCaps,
            deliveryCountLegacyFallback,
            planHash: configPlanHash,
            confirmToken: configConfirmToken
          })
        });
        const data = await jsonOrText(res);
        document.getElementById('config-set-result').textContent = JSON.stringify(data, null, 2);
        await loadSystemConfigStatus();
        return data;
      }

      function parseMode(value) {
        const mode = String(value || '').trim().toUpperCase();
        if (mode === 'OFF' || mode === 'DRY_RUN_ONLY' || mode === 'EXECUTE') return mode;
        return null;
      }

      async function loadAutomationConfigStatus() {
        const res = await fetch('/api/admin/os/automation-config/status', { headers: buildHeaders() });
        const data = await jsonOrText(res);
        document.getElementById('automation-config-status').textContent = JSON.stringify(data, null, 2);
        if (data && data.ok && data.config && data.config.mode) {
          document.getElementById('automation-config-mode').value = String(data.config.mode);
        }
        return data;
      }

      async function planAutomationConfig() {
        const mode = parseMode(document.getElementById('automation-config-mode').value);
        if (!mode) {
          document.getElementById('automation-config-plan-result').textContent = JSON.stringify({ ok: false, error: '不正なモードです' }, null, 2);
          return { ok: false, error: '不正なモードです' };
        }
        const res = await fetch('/api/admin/os/automation-config/plan', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({ mode })
        });
        const data = await jsonOrText(res);
        document.getElementById('automation-config-plan-result').textContent = JSON.stringify(data, null, 2);
        automationPlanHash = data && data.ok ? data.planHash || null : null;
        automationConfirmToken = data && data.ok ? data.confirmToken || null : null;
        return data;
      }

      async function setAutomationConfig() {
        const mode = parseMode(document.getElementById('automation-config-mode').value);
        if (!mode) {
          document.getElementById('automation-config-set-result').textContent = JSON.stringify({ ok: false, error: '不正なモードです' }, null, 2);
          return { ok: false, error: '不正なモードです' };
        }
        if (!automationPlanHash || !automationConfirmToken) {
          document.getElementById('automation-config-set-result').textContent = JSON.stringify({ ok: false, error: '計画が必要です' }, null, 2);
          return { ok: false, error: '計画が必要です' };
        }
        const ok = window.confirm(`Automation Config を set しますか？\n\nmode=${mode}`); // eslint-disable-line no-alert
        if (!ok) return { ok: false, error: 'キャンセルしました' };
        const res = await fetch('/api/admin/os/automation-config/set', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({ mode, planHash: automationPlanHash, confirmToken: automationConfirmToken })
        });
        const data = await jsonOrText(res);
        document.getElementById('automation-config-set-result').textContent = JSON.stringify(data, null, 2);
        await loadAutomationConfigStatus();
        return data;
      }

      function getDeliveryRecoveryPayload() {
        const deliveryId = document.getElementById('delivery-recovery-id').value.trim();
        const sealedReason = document.getElementById('delivery-recovery-reason').value.trim();
        if (!deliveryId) return { ok: false, error: '配信IDが必要です' };
        return {
          ok: true,
          payload: {
            deliveryId,
            sealedReason: sealedReason || null
          }
        };
      }

      async function loadDeliveryRecoveryStatus() {
        const parsed = getDeliveryRecoveryPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-recovery-status-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return { ok: false, error: parsed.error };
        }
        const params = new URLSearchParams({ deliveryId: parsed.payload.deliveryId });
        const res = await fetch(`/api/admin/os/delivery-recovery/status?${params.toString()}`, { headers: buildHeaders() });
        const data = await jsonOrText(res);
        document.getElementById('delivery-recovery-status-result').textContent = JSON.stringify(data, null, 2);
        const rec = data && data.delivery && data.delivery.recovery ? data.delivery.recovery : null;
        const recommendationText = rec
          ? `${formatDeliveryRecoveryRecommendation(rec)}\n\nraw:\n${JSON.stringify(rec, null, 2)}`
          : 'no recommendation';
        document.getElementById('delivery-recovery-recommendation').textContent = recommendationText;
        return data;
      }

      async function planDeliveryRecovery() {
        const parsed = getDeliveryRecoveryPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-recovery-plan-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return { ok: false, error: parsed.error };
        }
        const res = await fetch('/api/admin/os/delivery-recovery/plan', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(parsed.payload)
        });
        const data = await jsonOrText(res);
        document.getElementById('delivery-recovery-plan-result').textContent = JSON.stringify(data, null, 2);
        deliveryRecoveryPlanHash = data && data.ok ? data.planHash || null : null;
        deliveryRecoveryConfirmToken = data && data.ok ? data.confirmToken || null : null;
        return data;
      }

      async function executeDeliveryRecovery() {
        const parsed = getDeliveryRecoveryPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-recovery-execute-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return { ok: false, error: parsed.error };
        }
        if (!deliveryRecoveryPlanHash || !deliveryRecoveryConfirmToken) {
          document.getElementById('delivery-recovery-execute-result').textContent = JSON.stringify({ ok: false, error: '計画が必要です' }, null, 2);
          return { ok: false, error: '計画が必要です' };
        }
        const ok = window.confirm(`delivery recovery を実行しますか？\n\ndeliveryId=${parsed.payload.deliveryId}\nsealedReason=${parsed.payload.sealedReason || '(null)'}`); // eslint-disable-line no-alert
        if (!ok) return { ok: false, error: 'キャンセルしました' };
        const res = await fetch('/api/admin/os/delivery-recovery/execute', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(Object.assign({}, parsed.payload, {
            planHash: deliveryRecoveryPlanHash,
            confirmToken: deliveryRecoveryConfirmToken
          }))
        });
        const data = await jsonOrText(res);
        document.getElementById('delivery-recovery-execute-result').textContent = JSON.stringify(data, null, 2);
        await loadDeliveryRecoveryStatus();
        return data;
      }

      function getDeliveryBackfillPayload() {
        const parsed = parseBackfillLimit(document.getElementById('delivery-backfill-limit').value);
        if (!parsed.ok) return parsed;
        return { ok: true, payload: { limit: parsed.value } };
      }

      async function loadDeliveryBackfillStatus() {
        const parsed = getDeliveryBackfillPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-backfill-status-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return { ok: false, error: parsed.error };
        }
        const params = new URLSearchParams({ limit: String(parsed.payload.limit) });
        const res = await fetch(`/api/admin/os/delivery-backfill/status?${params.toString()}`, { headers: buildHeaders() });
        const data = await jsonOrText(res);
        document.getElementById('delivery-backfill-status-result').textContent = JSON.stringify(data, null, 2);
        return data;
      }

      async function planDeliveryBackfill() {
        const parsed = getDeliveryBackfillPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-backfill-plan-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return { ok: false, error: parsed.error };
        }
        const res = await fetch('/api/admin/os/delivery-backfill/plan', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(parsed.payload)
        });
        const data = await jsonOrText(res);
        document.getElementById('delivery-backfill-plan-result').textContent = JSON.stringify(data, null, 2);
        deliveryBackfillPlanHash = data && data.ok ? data.planHash || null : null;
        deliveryBackfillConfirmToken = data && data.ok ? data.confirmToken || null : null;
        return data;
      }

      async function executeDeliveryBackfill() {
        const parsed = getDeliveryBackfillPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-backfill-execute-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return { ok: false, error: parsed.error };
        }
        if (!deliveryBackfillPlanHash || !deliveryBackfillConfirmToken) {
          document.getElementById('delivery-backfill-execute-result').textContent = JSON.stringify({ ok: false, error: '計画が必要です' }, null, 2);
          return { ok: false, error: '計画が必要です' };
        }
        const ok = window.confirm(`delivery deliveredAt backfill を実行しますか？\n\nlimit=${parsed.payload.limit}`); // eslint-disable-line no-alert
        if (!ok) return { ok: false, error: 'キャンセルしました' };
        const res = await fetch('/api/admin/os/delivery-backfill/execute', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(Object.assign({}, parsed.payload, {
            planHash: deliveryBackfillPlanHash,
            confirmToken: deliveryBackfillConfirmToken
          }))
        });
        const data = await jsonOrText(res);
        document.getElementById('delivery-backfill-execute-result').textContent = JSON.stringify(data, null, 2);
        await loadDeliveryBackfillStatus();
        return data;
      }

      document.getElementById('tpl-reload').addEventListener('click', () => runWithToast('templates 更新', loadTemplates));
      document.getElementById('tpl-create').addEventListener('click', () => runWithToast('template 作成', createTemplate));
      document.getElementById('link-reload').addEventListener('click', () => runWithToast('link 更新', loadLinks));
      document.getElementById('link-create').addEventListener('click', () => runWithToast('link 作成', createLink));
      document.getElementById('redac-unlink').addEventListener('click', () => runWithToast('redac unlink', unlinkRedacMembership));
      document.getElementById('redac-health-reload').addEventListener('click', () => runWithToast('redac health 更新', loadRedacStatus));
      document.getElementById('config-reload').addEventListener('click', () => runWithToast('システム設定 更新', loadSystemConfigStatus));
      document.getElementById('llm-config-reload').addEventListener('click', () => runWithToast('LLM設定 更新', loadLlmConfigStatus));
      document.getElementById('llm-config-plan').addEventListener('click', () => runWithToast('LLM設定 計画', planLlmConfig));
      document.getElementById('llm-config-set').addEventListener('click', () => runWithToast('LLM設定 適用', setLlmConfig));
      document.getElementById('llm-faq-answer').addEventListener('click', () => runWithToast('LLM FAQ', generateLlmFaqAnswer));
      document.getElementById('llm-ops-explain').addEventListener('click', () => runWithToast('LLM Ops説明', fetchLlmOpsExplain));
      document.getElementById('llm-next-actions').addEventListener('click', () => runWithToast('LLM 次候補', fetchLlmNextActions));
      document.getElementById('config-plan').addEventListener('click', () => runWithToast('システム設定 計画', planSystemConfig));
      document.getElementById('config-set').addEventListener('click', () => runWithToast('システム設定 適用', setSystemConfig));
      document.getElementById('automation-config-reload').addEventListener('click', () => runWithToast('自動化設定 更新', loadAutomationConfigStatus));
      document.getElementById('automation-config-plan').addEventListener('click', () => runWithToast('自動化設定 計画', planAutomationConfig));
      document.getElementById('automation-config-set').addEventListener('click', () => runWithToast('自動化設定 適用', setAutomationConfig));
      document.getElementById('delivery-recovery-status').addEventListener('click', () => runWithToast('delivery recovery status', loadDeliveryRecoveryStatus));
      document.getElementById('delivery-recovery-plan').addEventListener('click', () => runWithToast('delivery recovery plan', planDeliveryRecovery));
      document.getElementById('delivery-recovery-execute').addEventListener('click', () => runWithToast('delivery recovery execute', executeDeliveryRecovery));
      document.getElementById('delivery-backfill-status').addEventListener('click', () => runWithToast('delivery backfill status', loadDeliveryBackfillStatus));
      document.getElementById('delivery-backfill-plan').addEventListener('click', () => runWithToast('delivery backfill plan', planDeliveryBackfill));
      document.getElementById('delivery-backfill-execute').addEventListener('click', () => runWithToast('delivery backfill execute', executeDeliveryBackfill));

      applyHeaderTooltips();
      applyInputTooltips();
      setLoading(true);
      Promise.all([
        loadTemplates(),
        loadLinks(),
        loadRedacStatus(),
        loadSystemConfigStatus(),
        loadLlmConfigStatus(),
        loadAutomationConfigStatus(),
        loadDeliveryBackfillStatus()
      ]).catch(() => {
        setStatusTone('danger');
      }).finally(() => {
        setLoading(false);
      });
    </script>
  </body>
</html>
