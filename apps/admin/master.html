<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Master Data（運用OS）</title>
    <style>
      body { font-family: system-ui, sans-serif; margin: 16px; color: #222; }
      .nav a { margin-right: 12px; }
      .note { font-size: 12px; color: #666; margin: 8px 0; }
      .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; align-items: start; }
      label { display: block; font-size: 12px; color: #333; margin-top: 8px; }
      input, textarea, select { width: 100%; padding: 6px 8px; font-size: 14px; }
      textarea { min-height: 80px; }
      button { padding: 6px 10px; font-size: 14px; }
      table { width: 100%; border-collapse: collapse; }
      th, td { border-bottom: 1px solid #eee; padding: 6px; text-align: left; font-size: 13px; }
      th { background: #f7f7f7; }
      pre { background: #f7f7f7; padding: 8px; border: 1px solid #eee; overflow: auto; }
    </style>
  </head>
  <body>
    <div class="nav">
      <a href="/admin/ops">ops</a>
      <a href="/admin/composer">composer</a>
      <a href="/admin/monitor">monitor</a>
      <a href="/admin/errors">errors</a>
    </div>

    <h1>Master Data（運用OS）</h1>
    <div class="note">templates / link_registry を UI から管理（add-only）。</div>

    <div class="note">
      traceId:
      <input type="text" id="traceId" style="max-width: 420px;" />
      <button id="regen-trace" type="button">regen</button>
      <span id="trace-note"></span>
    </div>

    <div class="grid">
      <div>
        <h2>Templates</h2>
        <div class="note">API: `/api/phase61/templates`</div>
        <div class="note">
          status:
          <select id="tpl-status">
            <option value="">(all)</option>
            <option value="draft">draft</option>
            <option value="active">active</option>
            <option value="inactive">inactive</option>
          </select>
          <button id="tpl-reload" type="button">reload</button>
        </div>
        <table>
          <thead>
            <tr><th>key</th><th>status</th><th>category</th><th>title</th><th>actions</th></tr>
          </thead>
          <tbody id="tpl-rows"></tbody>
        </table>

        <h3>Create Template</h3>
        <label>key</label>
        <input id="tpl-key" placeholder="ops_escalate" />
        <label>title</label>
        <input id="tpl-title" />
        <label>notificationCategory</label>
        <select id="tpl-category">
          <option value="DEADLINE_REQUIRED">DEADLINE_REQUIRED</option>
          <option value="IMMEDIATE_ACTION">IMMEDIATE_ACTION</option>
          <option value="SEQUENCE_GUIDANCE" selected>SEQUENCE_GUIDANCE</option>
          <option value="TARGETED_ONLY">TARGETED_ONLY</option>
          <option value="COMPLETION_CONFIRMATION">COMPLETION_CONFIRMATION</option>
        </select>
        <label>text/body</label>
        <textarea id="tpl-text"></textarea>
        <button id="tpl-create" type="button">create</button>
        <pre id="tpl-result">-</pre>
      </div>

      <div>
        <h2>Link Registry</h2>
        <div class="note">API: `/admin/link-registry`</div>
        <div class="note">
          state:
          <select id="link-state">
            <option value="">(all)</option>
            <option value="OK">OK</option>
            <option value="WARN">WARN</option>
          </select>
          <button id="link-reload" type="button">reload</button>
        </div>
        <table>
          <thead>
            <tr><th>id</th><th>title</th><th>url</th><th>state</th></tr>
          </thead>
          <tbody id="link-rows"></tbody>
        </table>

        <h3>Create Link</h3>
        <label>title</label>
        <input id="link-title" />
        <label>url</label>
        <input id="link-url" placeholder="https://..." />
        <button id="link-create" type="button">create</button>
        <pre id="link-result">-</pre>
      </div>
    </div>

    <hr />

    <h2>Redacクラブ会員ID（例外解除）</h2>
    <div class="note">
      重複拒否（B）の運用で詰まった場合のみ使用。入力した会員ID全文は保存しない（HMAC hash + last4のみ）。
      誰に紐付いているかは「解除結果」でのみ返る（運用者向け）。
    </div>
    <label>redacMembershipId（例: 00-0000）</label>
    <input id="redac-unlink-id" placeholder="00-0000" />
    <button id="redac-unlink" type="button">unlink</button>
    <pre id="redac-unlink-result">-</pre>

    <hr />

    <h2>Redac Health（運用確認）</h2>
    <div class="note">
      Redac運用の整合性を確認する。secret設定有無、ユーザーとlinkの不整合（sample内）を表示。
    </div>
    <div class="note">
      <button id="redac-health-reload" type="button">reload status</button>
    </div>
    <pre id="redac-health-result">-</pre>

    <hr />

    <h2>System Config（SSOT）</h2>
    <div class="note">servicePhase / notificationPreset を安全に変更（plan → confirmToken → set）。</div>
    <div class="note">
      <button id="config-reload" type="button">reload status</button>
    </div>
    <pre id="config-status">-</pre>

    <div class="grid">
      <div>
        <label>servicePhase（null = clear）</label>
        <select id="config-service-phase">
          <option value="">(null)</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
        </select>
      </div>
      <div>
        <label>notificationPreset（null = clear）</label>
        <select id="config-notification-preset">
          <option value="">(null)</option>
          <option value="A">A</option>
          <option value="B">B</option>
          <option value="C">C</option>
        </select>
      </div>
      <div>
        <label>notificationCaps.perUserWeeklyCap（null = clear）</label>
        <input id="config-notification-cap-weekly" placeholder="(null or integer)" />
      </div>
      <div>
        <label>notificationCaps.perUserDailyCap（null = clear）</label>
        <input id="config-notification-cap-daily" placeholder="(null or integer)" />
      </div>
      <div>
        <label>notificationCaps.perCategoryWeeklyCap（null = clear）</label>
        <input id="config-notification-cap-category-weekly" placeholder="(null or integer)" />
      </div>
      <div>
        <label>notificationCaps.quietHours.startHourUtc（null = clear）</label>
        <input id="config-notification-quiet-start" placeholder="0-23" />
      </div>
      <div>
        <label>notificationCaps.quietHours.endHourUtc（null = clear）</label>
        <input id="config-notification-quiet-end" placeholder="0-23" />
      </div>
      <div>
        <label>deliveryCountLegacyFallback（false = deliveredAtのみで集計）</label>
        <select id="config-delivery-count-legacy-fallback">
          <option value="true">true</option>
          <option value="false">false</option>
        </select>
      </div>
    </div>
    <div class="note">
      <button id="config-plan" type="button">plan</button>
      <button id="config-set" type="button">set</button>
    </div>
    <pre id="config-plan-result">-</pre>
    <pre id="config-impact-preview">-</pre>
    <pre id="config-set-result">-</pre>

    <hr />

    <h2>Automation Config（Segment Execute Guard）</h2>
    <div class="note">automation mode を安全に変更（plan → confirmToken → set）。</div>
    <div class="note">
      <button id="automation-config-reload" type="button">reload status</button>
    </div>
    <pre id="automation-config-status">-</pre>
    <label>mode</label>
    <select id="automation-config-mode">
      <option value="OFF">OFF</option>
      <option value="DRY_RUN_ONLY">DRY_RUN_ONLY</option>
      <option value="EXECUTE">EXECUTE</option>
    </select>
    <div class="note">
      <button id="automation-config-plan" type="button">plan</button>
      <button id="automation-config-set" type="button">set</button>
    </div>
    <pre id="automation-config-plan-result">-</pre>
    <pre id="automation-config-set-result">-</pre>

    <hr />

    <h2>Delivery Recovery（seal）</h2>
    <div class="note">
      送信前に reserve 済みで詰まった delivery を「sealed」にして回復操作を完了扱いにする。
      sealed は送信対象から skip される（再送しない）。
    </div>
    <label>deliveryId</label>
    <input id="delivery-recovery-id" placeholder="delivery id" />
    <label>sealedReason（任意）</label>
    <input id="delivery-recovery-reason" placeholder="manual_recovery" />
    <div class="note">
      <button id="delivery-recovery-status" type="button">status</button>
      <button id="delivery-recovery-plan" type="button">plan</button>
      <button id="delivery-recovery-execute" type="button">execute(seal)</button>
    </div>
    <pre id="delivery-recovery-status-result">-</pre>
    <pre id="delivery-recovery-recommendation">-</pre>
    <pre id="delivery-recovery-plan-result">-</pre>
    <pre id="delivery-recovery-execute-result">-</pre>

    <hr />

    <h2>Delivery deliveredAt Backfill</h2>
    <div class="note">
      旧delivery（`delivered=true` だが `deliveredAt` 欠損）のみを対象に、`sentAt` から `deliveredAt` を補完する。
      危険操作のため plan → confirmToken → execute でのみ反映。
    </div>
    <label>limit（1-1000）</label>
    <input id="delivery-backfill-limit" placeholder="200" />
    <div class="note">
      <button id="delivery-backfill-status" type="button">status</button>
      <button id="delivery-backfill-plan" type="button">plan</button>
      <button id="delivery-backfill-execute" type="button">execute(backfill)</button>
    </div>
    <pre id="delivery-backfill-status-result">-</pre>
    <pre id="delivery-backfill-plan-result">-</pre>
    <pre id="delivery-backfill-execute-result">-</pre>

    <script>
      const ACTOR_HEADERS = { 'x-actor': 'admin_master' };
      const TRACE_HEADER_NAME = 'x-trace-id';
      let configPlanHash = null;
      let configConfirmToken = null;
      let automationPlanHash = null;
      let automationConfirmToken = null;
      let deliveryRecoveryPlanHash = null;
      let deliveryRecoveryConfirmToken = null;
      let deliveryBackfillPlanHash = null;
      let deliveryBackfillConfirmToken = null;

      function newTraceId() {
        if (globalThis.crypto && typeof globalThis.crypto.randomUUID === 'function') {
          return globalThis.crypto.randomUUID();
        }
        return `trace-${Date.now()}-${Math.floor(Math.random() * 1e9)}`;
      }

      function getTraceId() {
        const el = document.getElementById('traceId');
        const value = el.value.trim();
        return value.length ? value : null;
      }

      function setTraceId(value) {
        const el = document.getElementById('traceId');
        el.value = value || '';
      }

      function ensureTraceId() {
        const value = getTraceId();
        if (value) return value;
        const next = newTraceId();
        setTraceId(next);
        return next;
      }

      function buildHeaders(extra) {
        const traceId = ensureTraceId();
        return Object.assign({}, extra || {}, ACTOR_HEADERS, { [TRACE_HEADER_NAME]: traceId });
      }

      document.getElementById('regen-trace').addEventListener('click', () => {
        setTraceId(newTraceId());
        document.getElementById('trace-note').textContent = '';
      });

      setTraceId(newTraceId());

      // Best-effort view audit (do not block UI).
      (async () => {
        try {
          const traceId = ensureTraceId();
          await fetch('/api/admin/os/view', {
            method: 'POST',
            headers: Object.assign({ 'content-type': 'application/json; charset=utf-8', [TRACE_HEADER_NAME]: traceId }, ACTOR_HEADERS),
            body: JSON.stringify({ screen: 'master' })
          });
        } catch (_err) {}
      })();

      function clearChildren(el) {
        while (el.firstChild) el.removeChild(el.firstChild);
      }

      function appendMessageRow(tbody, colSpan, message) {
        clearChildren(tbody);
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = colSpan;
        td.textContent = message;
        tr.appendChild(td);
        tbody.appendChild(tr);
      }

      function appendRow(tbody, values) {
        const tr = document.createElement('tr');
        for (const value of values) {
          const td = document.createElement('td');
          if (value instanceof Node) {
            td.appendChild(value);
          } else {
            td.textContent = value === null || value === undefined ? '-' : String(value);
          }
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }

      function jsonOrText(res) {
        return res.text().then((text) => {
          try { return JSON.parse(text); } catch (_err) { return { ok: false, error: text || 'error' }; }
        });
      }

      function sortedEntries(obj) {
        return Object.entries(obj || {}).sort((a, b) => {
          if (a[0] === b[0]) return 0;
          return a[0] > b[0] ? 1 : -1;
        });
      }

      function formatBreakdownRows(label, rows) {
        const list = Array.isArray(rows) ? rows : [];
        if (!list.length) return [];
        const lines = [`${label}:`];
        for (const row of list) {
          if (!row || typeof row !== 'object') continue;
          const key = row.key || '-';
          const count = Number.isFinite(row.count) ? row.count : 0;
          const ratePercent = Number.isFinite(row.ratePercent) ? row.ratePercent : 0;
          lines.push(`- ${key}: ${count} (${ratePercent}%)`);
        }
        return lines;
      }

      function formatImpactPreview(preview) {
        if (!preview || typeof preview !== 'object') return 'impact preview unavailable';
        const sampledUsers = Number.isFinite(preview.sampledUsers) ? preview.sampledUsers : 0;
        const sampledEvaluations = Number.isFinite(preview.sampledEvaluations) ? preview.sampledEvaluations : sampledUsers;
        const blockedEvaluations = Number.isFinite(preview.blockedEvaluations) ? preview.blockedEvaluations : 0;
        const estimatedBlockedUsers = Number.isFinite(preview.estimatedBlockedUsers) ? preview.estimatedBlockedUsers : 0;
        const estimatedBlockedUserRatePercent = Number.isFinite(preview.estimatedBlockedUserRatePercent)
          ? preview.estimatedBlockedUserRatePercent
          : 0;
        const blockedEvaluationRatePercent = Number.isFinite(preview.blockedEvaluationRatePercent)
          ? preview.blockedEvaluationRatePercent
          : 0;
        const topBlockedCapType = preview.topBlockedCapType ? String(preview.topBlockedCapType) : '(none)';
        const topBlockedCategory = preview.topBlockedCategory ? String(preview.topBlockedCategory) : '(none)';
        const blockedByCapType = sortedEntries(preview.blockedByCapType);
        const blockedByCategory = sortedEntries(preview.blockedByCategory);
        const blockedByReason = sortedEntries(preview.blockedByReason);
        const categories = Array.isArray(preview.simulatedCategories) ? preview.simulatedCategories : [];
        const notes = Array.isArray(preview.notes) ? preview.notes : [];
        const riskLevel = preview.riskLevel ? String(preview.riskLevel) : 'UNKNOWN';
        const recommendedAction = preview.recommendedAction ? String(preview.recommendedAction) : 'REVIEW_BEFORE_SET';
        const lines = [
          `sampledUsers: ${sampledUsers}`,
          `sampledEvaluations: ${sampledEvaluations}`,
          `blockedEvaluations: ${blockedEvaluations}`,
          `blockedEvaluationRatePercent: ${blockedEvaluationRatePercent}`,
          `estimatedBlockedUsers: ${estimatedBlockedUsers}`,
          `estimatedBlockedUserRatePercent: ${estimatedBlockedUserRatePercent}`,
          `riskLevel: ${riskLevel}`,
          `recommendedAction: ${recommendedAction}`,
          `topBlockedCapType: ${topBlockedCapType}`,
          `topBlockedCategory: ${topBlockedCategory}`,
          `simulatedCategories: ${categories.length ? categories.join(', ') : '(none)'}`
        ];
        const capTypeBreakdown = formatBreakdownRows('capTypeBreakdown', preview.capTypeBreakdown);
        const reasonBreakdown = formatBreakdownRows('reasonBreakdown', preview.reasonBreakdown);
        const categoryBreakdown = formatBreakdownRows('categoryBreakdown', preview.categoryBreakdown);
        lines.push(...capTypeBreakdown);
        lines.push(...reasonBreakdown);
        lines.push(...categoryBreakdown);
        if (blockedByCapType.length) {
          lines.push('blockedByCapType:');
          for (const [k, v] of blockedByCapType) lines.push(`- ${k}: ${v}`);
        }
        if (blockedByCategory.length) {
          lines.push('blockedByCategory:');
          for (const [k, v] of blockedByCategory) lines.push(`- ${k}: ${v}`);
        }
        if (blockedByReason.length) {
          lines.push('blockedByReason:');
          for (const [k, v] of blockedByReason) lines.push(`- ${k}: ${v}`);
        }
        if (notes.length) {
          lines.push('notes:');
          for (const note of notes) lines.push(`- ${String(note)}`);
        }
        return lines.join('\n');
      }

      function formatDeliveryRecoveryRecommendation(recovery) {
        const payload = recovery && typeof recovery === 'object' ? recovery : {};
        const recommendedAction = payload.recommendedAction ? String(payload.recommendedAction) : 'INSPECT';
        const allowedActions = Array.isArray(payload.allowedActions) ? payload.allowedActions : [];
        const retryPossible = payload.retryPossible === true;
        const canSeal = payload.canSeal === true;
        const lines = [
          `recommendedAction: ${recommendedAction}`,
          `allowedActions: ${allowedActions.length ? allowedActions.join(', ') : '(none)'}`,
          `retryPossible: ${retryPossible ? 'yes' : 'no'}`,
          `canSeal: ${canSeal ? 'yes' : 'no'}`
        ];
        lines.push('guide:');
        if (recommendedAction === 'NO_ACTION') {
          lines.push('- this delivery is already settled. no operation is required.');
        } else if (recommendedAction === 'RETRY_OR_SEAL') {
          lines.push('- retry first if cause is recoverable; use seal only when retry is not appropriate.');
        } else if (recommendedAction === 'SEAL') {
          lines.push('- use seal to close stuck reserved/in-flight records and avoid duplicate delivery.');
        } else {
          lines.push('- inspect audit/trace first, then choose action.');
        }
        return lines.join('\n');
      }

      async function loadTemplates() {
        const status = document.getElementById('tpl-status').value;
        const params = new URLSearchParams();
        if (status) params.set('status', status);
        const res = await fetch(`/api/phase61/templates${params.toString() ? `?${params.toString()}` : ''}`, { headers: buildHeaders() });
        const data = await res.json();
        const rows = document.getElementById('tpl-rows');
        if (!data.ok) {
          appendMessageRow(rows, 5, 'error');
          return;
        }
        const items = Array.isArray(data.items) ? data.items : [];
        if (!items.length) {
          appendMessageRow(rows, 5, 'no data');
          return;
        }
        clearChildren(rows);
        for (const item of items) {
          const actions = document.createElement('span');

          const activateBtn = document.createElement('button');
          activateBtn.type = 'button';
          activateBtn.textContent = 'activate';
          activateBtn.addEventListener('click', async () => {
            const key = item && item.key ? String(item.key) : '';
            if (!key) return;
            const res2 = await fetch(`/api/phase61/templates/${encodeURIComponent(key)}/activate`, {
              method: 'POST',
              headers: buildHeaders()
            });
            document.getElementById('tpl-result').textContent = JSON.stringify(await res2.json(), null, 2);
            await loadTemplates();
          });
          actions.appendChild(activateBtn);

          const space = document.createTextNode(' ');
          actions.appendChild(space);

          const deactivateBtn = document.createElement('button');
          deactivateBtn.type = 'button';
          deactivateBtn.textContent = 'deactivate';
          deactivateBtn.addEventListener('click', async () => {
            const key = item && item.key ? String(item.key) : '';
            if (!key) return;
            const res2 = await fetch(`/api/phase61/templates/${encodeURIComponent(key)}/deactivate`, {
              method: 'POST',
              headers: buildHeaders()
            });
            document.getElementById('tpl-result').textContent = JSON.stringify(await res2.json(), null, 2);
            await loadTemplates();
          });
          actions.appendChild(deactivateBtn);

          appendRow(rows, [
            item.key || '-',
            item.status || '-',
            item.notificationCategory || '-',
            item.title || '-',
            actions
          ]);
        }
      }

      async function createTemplate() {
        const payload = {
          key: document.getElementById('tpl-key').value.trim(),
          title: document.getElementById('tpl-title').value.trim(),
          notificationCategory: document.getElementById('tpl-category').value,
          text: document.getElementById('tpl-text').value
        };
        const res = await fetch('/api/phase61/templates', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(payload)
        });
        document.getElementById('tpl-result').textContent = JSON.stringify(await res.json(), null, 2);
        await loadTemplates();
      }

      async function loadLinks() {
        const state = document.getElementById('link-state').value;
        const params = new URLSearchParams();
        if (state) params.set('state', state);
        const res = await fetch(`/admin/link-registry${params.toString() ? `?${params.toString()}` : ''}`, { headers: buildHeaders() });
        const data = await res.json();
        const rows = document.getElementById('link-rows');
        if (!data.ok) {
          appendMessageRow(rows, 4, 'error');
          return;
        }
        const items = Array.isArray(data.items) ? data.items : [];
        if (!items.length) {
          appendMessageRow(rows, 4, 'no data');
          return;
        }
        clearChildren(rows);
        for (const item of items) {
          appendRow(rows, [
            item.id || '-',
            item.title || '-',
            item.url || '-',
            item.lastHealth && item.lastHealth.state ? item.lastHealth.state : '-'
          ]);
        }
      }

      async function createLink() {
        const payload = {
          title: document.getElementById('link-title').value.trim(),
          url: document.getElementById('link-url').value.trim()
        };
        const res = await fetch('/admin/link-registry', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(payload)
        });
        document.getElementById('link-result').textContent = JSON.stringify(await jsonOrText(res), null, 2);
        await loadLinks();
      }

      async function unlinkRedacMembership() {
        const redacMembershipId = document.getElementById('redac-unlink-id').value.trim();
        if (!redacMembershipId) return;
        const ok = window.confirm(`Redac会員IDを解除しますか？\n\n${redacMembershipId}\n\n(例外対応: 通常は使いません)`); // eslint-disable-line no-alert
        if (!ok) return;
        const res = await fetch('/api/admin/redac-membership/unlink', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({ redacMembershipId })
        });
        document.getElementById('redac-unlink-result').textContent = JSON.stringify(await jsonOrText(res), null, 2);
      }

      async function loadRedacStatus() {
        const res = await fetch('/api/admin/os/redac/status?limit=500', {
          headers: buildHeaders()
        });
        document.getElementById('redac-health-result').textContent = JSON.stringify(await jsonOrText(res), null, 2);
      }

      function parseNullableInt(value) {
        const trimmed = String(value || '').trim();
        if (!trimmed) return null;
        const num = Number(trimmed);
        if (!Number.isInteger(num)) return null;
        return num;
      }

      function parseNullableString(value) {
        const trimmed = String(value || '').trim();
        return trimmed ? trimmed : null;
      }

      function parseNullablePositiveInt(value) {
        const trimmed = String(value || '').trim();
        if (!trimmed) return { ok: true, value: null };
        const num = Number(trimmed);
        if (!Number.isInteger(num) || num < 1) return { ok: false, error: 'cap must be a positive integer or empty' };
        return { ok: true, value: num };
      }

      function parseNullableHour(value) {
        const trimmed = String(value || '').trim();
        if (!trimmed) return { ok: true, value: null };
        const num = Number(trimmed);
        if (!Number.isInteger(num) || num < 0 || num > 23) {
          return { ok: false, error: 'quietHours must be 0-23 or empty' };
        }
        return { ok: true, value: num };
      }

      function readNotificationCapsFromForm() {
        const weekly = parseNullablePositiveInt(document.getElementById('config-notification-cap-weekly').value);
        if (!weekly.ok) return weekly;
        const daily = parseNullablePositiveInt(document.getElementById('config-notification-cap-daily').value);
        if (!daily.ok) return daily;
        const categoryWeekly = parseNullablePositiveInt(document.getElementById('config-notification-cap-category-weekly').value);
        if (!categoryWeekly.ok) return categoryWeekly;
        const quietStart = parseNullableHour(document.getElementById('config-notification-quiet-start').value);
        if (!quietStart.ok) return quietStart;
        const quietEnd = parseNullableHour(document.getElementById('config-notification-quiet-end').value);
        if (!quietEnd.ok) return quietEnd;

        let quietHours = null;
        if (quietStart.value !== null || quietEnd.value !== null) {
          if (quietStart.value === null || quietEnd.value === null) {
            return { ok: false, error: 'quietHours start/end must both be set or both empty' };
          }
          quietHours = {
            startHourUtc: quietStart.value,
            endHourUtc: quietEnd.value
          };
        }
        return {
          ok: true,
          value: {
            perUserWeeklyCap: weekly.value,
            perUserDailyCap: daily.value,
            perCategoryWeeklyCap: categoryWeekly.value,
            quietHours
          }
        };
      }

      function parseDeliveryCountLegacyFallback(value) {
        return String(value || '').trim().toLowerCase() !== 'false';
      }

      function parseBackfillLimit(value) {
        const trimmed = String(value || '').trim();
        if (!trimmed) return { ok: true, value: 200 };
        const num = Number(trimmed);
        if (!Number.isInteger(num) || num < 1 || num > 1000) {
          return { ok: false, error: 'limit must be integer 1-1000' };
        }
        return { ok: true, value: num };
      }

      async function loadSystemConfigStatus() {
        const res = await fetch('/api/admin/os/config/status', { headers: buildHeaders() });
        const data = await jsonOrText(res);
        document.getElementById('config-status').textContent = JSON.stringify(data, null, 2);
        if (data && data.ok) {
          const sp = data.servicePhase === null || data.servicePhase === undefined ? '' : String(data.servicePhase);
          document.getElementById('config-service-phase').value = sp;
          const preset = data.notificationPreset ? String(data.notificationPreset) : '';
          document.getElementById('config-notification-preset').value = preset;
          const weeklyCap = data.notificationCaps && data.notificationCaps.perUserWeeklyCap !== null && data.notificationCaps.perUserWeeklyCap !== undefined
            ? String(data.notificationCaps.perUserWeeklyCap)
            : '';
          document.getElementById('config-notification-cap-weekly').value = weeklyCap;
          const dailyCap = data.notificationCaps && data.notificationCaps.perUserDailyCap !== null && data.notificationCaps.perUserDailyCap !== undefined
            ? String(data.notificationCaps.perUserDailyCap)
            : '';
          document.getElementById('config-notification-cap-daily').value = dailyCap;
          const categoryWeeklyCap = data.notificationCaps && data.notificationCaps.perCategoryWeeklyCap !== null && data.notificationCaps.perCategoryWeeklyCap !== undefined
            ? String(data.notificationCaps.perCategoryWeeklyCap)
            : '';
          document.getElementById('config-notification-cap-category-weekly').value = categoryWeeklyCap;
          const quietStart = data.notificationCaps && data.notificationCaps.quietHours && data.notificationCaps.quietHours.startHourUtc !== undefined
            ? String(data.notificationCaps.quietHours.startHourUtc)
            : '';
          const quietEnd = data.notificationCaps && data.notificationCaps.quietHours && data.notificationCaps.quietHours.endHourUtc !== undefined
            ? String(data.notificationCaps.quietHours.endHourUtc)
            : '';
          document.getElementById('config-notification-quiet-start').value = quietStart;
          document.getElementById('config-notification-quiet-end').value = quietEnd;
          const legacyFallback = data.deliveryCountLegacyFallback === false ? 'false' : 'true';
          document.getElementById('config-delivery-count-legacy-fallback').value = legacyFallback;
        }
      }

      async function planSystemConfig() {
        const servicePhase = parseNullableInt(document.getElementById('config-service-phase').value);
        const notificationPreset = parseNullableString(document.getElementById('config-notification-preset').value);
        const capParsed = readNotificationCapsFromForm();
        if (!capParsed.ok) {
          document.getElementById('config-plan-result').textContent = JSON.stringify({ ok: false, error: capParsed.error }, null, 2);
          return;
        }
        const deliveryCountLegacyFallback = parseDeliveryCountLegacyFallback(
          document.getElementById('config-delivery-count-legacy-fallback').value
        );
        const notificationCaps = capParsed.value;
        const res = await fetch('/api/admin/os/config/plan', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({ servicePhase, notificationPreset, notificationCaps, deliveryCountLegacyFallback })
        });
        const data = await jsonOrText(res);
        document.getElementById('config-plan-result').textContent = JSON.stringify(data, null, 2);
        const impactPreview = data && data.impactPreview ? data.impactPreview : { ok: false, error: 'impact preview unavailable' };
        document.getElementById('config-impact-preview').textContent = `${formatImpactPreview(impactPreview)}\n\nraw:\n${JSON.stringify(impactPreview, null, 2)}`;
        configPlanHash = data && data.ok ? data.planHash || null : null;
        configConfirmToken = data && data.ok ? data.confirmToken || null : null;
      }

      async function setSystemConfig() {
        const servicePhase = parseNullableInt(document.getElementById('config-service-phase').value);
        const notificationPreset = parseNullableString(document.getElementById('config-notification-preset').value);
        const capParsed = readNotificationCapsFromForm();
        if (!capParsed.ok) {
          document.getElementById('config-set-result').textContent = JSON.stringify({ ok: false, error: capParsed.error }, null, 2);
          return;
        }
        const deliveryCountLegacyFallback = parseDeliveryCountLegacyFallback(
          document.getElementById('config-delivery-count-legacy-fallback').value
        );
        const notificationCaps = capParsed.value;
        if (!configPlanHash || !configConfirmToken) {
          document.getElementById('config-set-result').textContent = JSON.stringify({ ok: false, error: 'plan required' }, null, 2);
          return;
        }
        const ok = window.confirm(`System Config を set しますか？\n\nservicePhase=${servicePhase === null ? 'null' : String(servicePhase)}\nnotificationPreset=${notificationPreset === null ? 'null' : String(notificationPreset)}\nnotificationCaps=${JSON.stringify(notificationCaps)}\ndeliveryCountLegacyFallback=${deliveryCountLegacyFallback}`); // eslint-disable-line no-alert
        if (!ok) return;
        const res = await fetch('/api/admin/os/config/set', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({
            servicePhase,
            notificationPreset,
            notificationCaps,
            deliveryCountLegacyFallback,
            planHash: configPlanHash,
            confirmToken: configConfirmToken
          })
        });
        const data = await jsonOrText(res);
        document.getElementById('config-set-result').textContent = JSON.stringify(data, null, 2);
        await loadSystemConfigStatus();
      }

      function parseMode(value) {
        const mode = String(value || '').trim().toUpperCase();
        if (mode === 'OFF' || mode === 'DRY_RUN_ONLY' || mode === 'EXECUTE') return mode;
        return null;
      }

      async function loadAutomationConfigStatus() {
        const res = await fetch('/api/admin/os/automation-config/status', { headers: buildHeaders() });
        const data = await jsonOrText(res);
        document.getElementById('automation-config-status').textContent = JSON.stringify(data, null, 2);
        if (data && data.ok && data.config && data.config.mode) {
          document.getElementById('automation-config-mode').value = String(data.config.mode);
        }
      }

      async function planAutomationConfig() {
        const mode = parseMode(document.getElementById('automation-config-mode').value);
        if (!mode) {
          document.getElementById('automation-config-plan-result').textContent = JSON.stringify({ ok: false, error: 'invalid mode' }, null, 2);
          return;
        }
        const res = await fetch('/api/admin/os/automation-config/plan', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({ mode })
        });
        const data = await jsonOrText(res);
        document.getElementById('automation-config-plan-result').textContent = JSON.stringify(data, null, 2);
        automationPlanHash = data && data.ok ? data.planHash || null : null;
        automationConfirmToken = data && data.ok ? data.confirmToken || null : null;
      }

      async function setAutomationConfig() {
        const mode = parseMode(document.getElementById('automation-config-mode').value);
        if (!mode) {
          document.getElementById('automation-config-set-result').textContent = JSON.stringify({ ok: false, error: 'invalid mode' }, null, 2);
          return;
        }
        if (!automationPlanHash || !automationConfirmToken) {
          document.getElementById('automation-config-set-result').textContent = JSON.stringify({ ok: false, error: 'plan required' }, null, 2);
          return;
        }
        const ok = window.confirm(`Automation Config を set しますか？\n\nmode=${mode}`); // eslint-disable-line no-alert
        if (!ok) return;
        const res = await fetch('/api/admin/os/automation-config/set', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify({ mode, planHash: automationPlanHash, confirmToken: automationConfirmToken })
        });
        const data = await jsonOrText(res);
        document.getElementById('automation-config-set-result').textContent = JSON.stringify(data, null, 2);
        await loadAutomationConfigStatus();
      }

      function getDeliveryRecoveryPayload() {
        const deliveryId = document.getElementById('delivery-recovery-id').value.trim();
        const sealedReason = document.getElementById('delivery-recovery-reason').value.trim();
        if (!deliveryId) return { ok: false, error: 'deliveryId required' };
        return {
          ok: true,
          payload: {
            deliveryId,
            sealedReason: sealedReason || null
          }
        };
      }

      async function loadDeliveryRecoveryStatus() {
        const parsed = getDeliveryRecoveryPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-recovery-status-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return;
        }
        const params = new URLSearchParams({ deliveryId: parsed.payload.deliveryId });
        const res = await fetch(`/api/admin/os/delivery-recovery/status?${params.toString()}`, { headers: buildHeaders() });
        const data = await jsonOrText(res);
        document.getElementById('delivery-recovery-status-result').textContent = JSON.stringify(data, null, 2);
        const rec = data && data.delivery && data.delivery.recovery ? data.delivery.recovery : null;
        const recommendationText = rec
          ? `${formatDeliveryRecoveryRecommendation(rec)}\n\nraw:\n${JSON.stringify(rec, null, 2)}`
          : 'no recommendation';
        document.getElementById('delivery-recovery-recommendation').textContent = recommendationText;
      }

      async function planDeliveryRecovery() {
        const parsed = getDeliveryRecoveryPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-recovery-plan-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return;
        }
        const res = await fetch('/api/admin/os/delivery-recovery/plan', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(parsed.payload)
        });
        const data = await jsonOrText(res);
        document.getElementById('delivery-recovery-plan-result').textContent = JSON.stringify(data, null, 2);
        deliveryRecoveryPlanHash = data && data.ok ? data.planHash || null : null;
        deliveryRecoveryConfirmToken = data && data.ok ? data.confirmToken || null : null;
      }

      async function executeDeliveryRecovery() {
        const parsed = getDeliveryRecoveryPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-recovery-execute-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return;
        }
        if (!deliveryRecoveryPlanHash || !deliveryRecoveryConfirmToken) {
          document.getElementById('delivery-recovery-execute-result').textContent = JSON.stringify({ ok: false, error: 'plan required' }, null, 2);
          return;
        }
        const ok = window.confirm(`delivery recovery を実行しますか？\n\ndeliveryId=${parsed.payload.deliveryId}\nsealedReason=${parsed.payload.sealedReason || '(null)'}`); // eslint-disable-line no-alert
        if (!ok) return;
        const res = await fetch('/api/admin/os/delivery-recovery/execute', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(Object.assign({}, parsed.payload, {
            planHash: deliveryRecoveryPlanHash,
            confirmToken: deliveryRecoveryConfirmToken
          }))
        });
        const data = await jsonOrText(res);
        document.getElementById('delivery-recovery-execute-result').textContent = JSON.stringify(data, null, 2);
        await loadDeliveryRecoveryStatus();
      }

      function getDeliveryBackfillPayload() {
        const parsed = parseBackfillLimit(document.getElementById('delivery-backfill-limit').value);
        if (!parsed.ok) return parsed;
        return { ok: true, payload: { limit: parsed.value } };
      }

      async function loadDeliveryBackfillStatus() {
        const parsed = getDeliveryBackfillPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-backfill-status-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return;
        }
        const params = new URLSearchParams({ limit: String(parsed.payload.limit) });
        const res = await fetch(`/api/admin/os/delivery-backfill/status?${params.toString()}`, { headers: buildHeaders() });
        const data = await jsonOrText(res);
        document.getElementById('delivery-backfill-status-result').textContent = JSON.stringify(data, null, 2);
      }

      async function planDeliveryBackfill() {
        const parsed = getDeliveryBackfillPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-backfill-plan-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return;
        }
        const res = await fetch('/api/admin/os/delivery-backfill/plan', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(parsed.payload)
        });
        const data = await jsonOrText(res);
        document.getElementById('delivery-backfill-plan-result').textContent = JSON.stringify(data, null, 2);
        deliveryBackfillPlanHash = data && data.ok ? data.planHash || null : null;
        deliveryBackfillConfirmToken = data && data.ok ? data.confirmToken || null : null;
      }

      async function executeDeliveryBackfill() {
        const parsed = getDeliveryBackfillPayload();
        if (!parsed.ok) {
          document.getElementById('delivery-backfill-execute-result').textContent = JSON.stringify({ ok: false, error: parsed.error }, null, 2);
          return;
        }
        if (!deliveryBackfillPlanHash || !deliveryBackfillConfirmToken) {
          document.getElementById('delivery-backfill-execute-result').textContent = JSON.stringify({ ok: false, error: 'plan required' }, null, 2);
          return;
        }
        const ok = window.confirm(`delivery deliveredAt backfill を実行しますか？\n\nlimit=${parsed.payload.limit}`); // eslint-disable-line no-alert
        if (!ok) return;
        const res = await fetch('/api/admin/os/delivery-backfill/execute', {
          method: 'POST',
          headers: buildHeaders({ 'content-type': 'application/json; charset=utf-8' }),
          body: JSON.stringify(Object.assign({}, parsed.payload, {
            planHash: deliveryBackfillPlanHash,
            confirmToken: deliveryBackfillConfirmToken
          }))
        });
        const data = await jsonOrText(res);
        document.getElementById('delivery-backfill-execute-result').textContent = JSON.stringify(data, null, 2);
        await loadDeliveryBackfillStatus();
      }

      document.getElementById('tpl-reload').addEventListener('click', () => loadTemplates().catch(() => {}));
      document.getElementById('tpl-create').addEventListener('click', () => createTemplate().catch(() => {}));
      document.getElementById('link-reload').addEventListener('click', () => loadLinks().catch(() => {}));
      document.getElementById('link-create').addEventListener('click', () => createLink().catch(() => {}));
      document.getElementById('redac-unlink').addEventListener('click', () => unlinkRedacMembership().catch(() => {}));
      document.getElementById('redac-health-reload').addEventListener('click', () => loadRedacStatus().catch(() => {}));
      document.getElementById('config-reload').addEventListener('click', () => loadSystemConfigStatus().catch(() => {}));
      document.getElementById('config-plan').addEventListener('click', () => planSystemConfig().catch(() => {}));
      document.getElementById('config-set').addEventListener('click', () => setSystemConfig().catch(() => {}));
      document.getElementById('automation-config-reload').addEventListener('click', () => loadAutomationConfigStatus().catch(() => {}));
      document.getElementById('automation-config-plan').addEventListener('click', () => planAutomationConfig().catch(() => {}));
      document.getElementById('automation-config-set').addEventListener('click', () => setAutomationConfig().catch(() => {}));
      document.getElementById('delivery-recovery-status').addEventListener('click', () => loadDeliveryRecoveryStatus().catch(() => {}));
      document.getElementById('delivery-recovery-plan').addEventListener('click', () => planDeliveryRecovery().catch(() => {}));
      document.getElementById('delivery-recovery-execute').addEventListener('click', () => executeDeliveryRecovery().catch(() => {}));
      document.getElementById('delivery-backfill-status').addEventListener('click', () => loadDeliveryBackfillStatus().catch(() => {}));
      document.getElementById('delivery-backfill-plan').addEventListener('click', () => planDeliveryBackfill().catch(() => {}));
      document.getElementById('delivery-backfill-execute').addEventListener('click', () => executeDeliveryBackfill().catch(() => {}));

      loadTemplates().catch(() => {});
      loadLinks().catch(() => {});
      loadRedacStatus().catch(() => {});
      loadSystemConfigStatus().catch(() => {});
      loadAutomationConfigStatus().catch(() => {});
      loadDeliveryBackfillStatus().catch(() => {});
    </script>
  </body>
</html>
