<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>運用判断支援（READ ONLY）</title>
    <style>
      body { font-family: system-ui, sans-serif; margin: 16px; color: #222; }
      table { width: 100%; border-collapse: collapse; margin-bottom: 24px; }
      th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; font-size: 14px; }
      th { background: #f7f7f7; }
      .note { font-size: 12px; color: #666; margin-bottom: 8px; }
      .section { margin-bottom: 24px; }
      .btn { font-size: 12px; padding: 4px 8px; }
      .badge { display: inline-block; padding: 2px 6px; border-radius: 6px; font-size: 12px; }
      .badge-danger { background: #ffe3e3; color: #a40000; }
      .badge-warn { background: #fff4d6; color: #7a4a00; }
      .badge-ok { background: #e6ffed; color: #0f5f2e; }
    </style>
  </head>
  <body>
    <h1>運用判断支援（READ ONLY）</h1>
    <div class="note">表示のみ。判断と操作は人間が行います。</div>
    <div class="note">
      運用ナビ:
      <a href="/admin/composer">Composer</a> →
      <a href="/admin/monitor">Monitor</a> →
      <a href="/admin/errors">Errors</a> →
      <a href="#trace-search">Trace</a>
    </div>
    <div class="note">
      <a href="/admin/read-model">通知集計</a> |
      <a href="/admin/composer">Composer</a> |
      <a href="/admin/monitor">Monitor</a> |
      <a href="/admin/errors">Errors</a> |
      <a href="/admin/master">Master</a> |
      <a href="#trace-search">Trace Search</a> |
      <a href="#implementation-targets">Implementation Targets</a>
    </div>

    <div class="section" id="operations">
      <h2>Operations（安全操作）</h2>
      <div class="note">危険操作（kill switch）は confirm token 必須。</div>
      <div class="note">
        killSwitch: <span id="kill-switch-state">-</span>
        / planHash: <span id="kill-switch-plan-hash">-</span>
        / confirmToken: <span id="kill-switch-confirm-token">-</span>
      </div>
      <div class="note">
        <button class="btn" id="kill-switch-refresh">refresh</button>
        <button class="btn" id="kill-switch-plan-on">plan ON</button>
        <button class="btn" id="kill-switch-plan-off">plan OFF</button>
        <button class="btn" id="kill-switch-set">set</button>
      </div>
      <pre id="kill-switch-result">-</pre>
    </div>

    <div class="section" id="trace-search">
      <h2>Trace Search（監査）</h2>
      <div class="note">traceId を入力して audit_logs / decision_logs / decision_timeline を参照。</div>
      <div class="note">
        traceId: <input type="text" id="trace-search-trace-id" style="min-width: 260px" />
        limit: <input type="number" id="trace-search-limit" min="1" max="200" value="50" />
        <button class="btn" id="trace-search-run">検索</button>
      </div>
      <pre id="trace-search-result">-</pre>
    </div>

    <div class="section">
      <h2>ユーザー状態一覧（READ ONLY）</h2>
      <div class="note">期間フィルタ（UTC）</div>
      <div class="note">
        from: <input type="date" id="users-from" />
        to: <input type="date" id="users-to" />
        <button class="btn" id="users-apply">適用</button>
      </div>
      <div class="note">
        <label><input type="checkbox" id="filter-needsAttention" /> needsAttention</label>
        <label><input type="checkbox" id="filter-stale" /> stale</label>
        <label><input type="checkbox" id="filter-unreviewed" /> unreviewed</label>
        <label>reviewAgeDays: <input type="number" id="filter-reviewAgeDays" min="1" max="365" /></label>
      </div>
      <div class="note" id="user-summary-note"></div>
      <table>
        <thead>
          <tr>
            <th>lineUserId</th>
            <th>memberNumber</th>
            <th>checklist</th>
            <th>stale</th>
            <th>needsAttention</th>
            <th>lastReviewedAt</th>
            <th>lastReviewedBy</th>
            <th>lastActionAt</th>
            <th>操作</th>
          </tr>
        </thead>
        <tbody id="users-rows"></tbody>
      </table>
    </div>

    <div class="section">
      <h2>通知状態一覧</h2>
      <div class="note">期間フィルタ（UTC）</div>
      <div class="note">最終反応はLINE-only定義（click優先、readは補助、openは内部イベント扱い）</div>
      <div class="note">
        from: <input type="date" id="notifications-from" />
        to: <input type="date" id="notifications-to" />
        <button class="btn" id="notifications-apply">適用</button>
      </div>
      <table>
        <thead>
          <tr>
            <th>notificationId</th>
            <th>sentAt</th>
            <th>open</th>
            <th>click</th>
            <th>最終反応（LINE定義）</th>
            <th>詳細</th>
          </tr>
        </thead>
        <tbody id="notifications-rows"></tbody>
      </table>
    </div>

    <div class="section" id="ops-dashboard-section">
      <h2>Ops Dashboard（Phase38）</h2>
      <div class="note">ユーザー×通知×notice×decision を一覧で参照。</div>
      <div class="note">
        limit: <input type="number" id="ops-dashboard-limit" min="1" max="200" value="20" />
        <button class="btn" id="ops-dashboard-refresh">更新</button>
      </div>
      <div class="note" id="ops-dashboard-note"></div>
      <div class="note" id="ops-dashboard-error"></div>
      <table>
        <thead>
          <tr>
            <th>lineUserId</th>
            <th>memberNumber</th>
            <th>lastDelivery</th>
            <th>lastNoticeSent</th>
            <th>latestDecisionLog</th>
          </tr>
        </thead>
        <tbody id="ops-dashboard-rows"></tbody>
      </table>
    </div>

    <div class="section" id="ops-console-list-section">
      <h2>Ops Console（Phase26 list）</h2>
      <div class="note">運用判断の一覧（READY優先・安定ソート）。</div>
      <div class="note">
        limit: <input type="number" id="ops-console-limit" min="1" max="200" value="20" />
        <button class="btn" id="ops-console-refresh">更新</button>
      </div>
      <div class="note" id="ops-console-list-note"></div>
      <div class="note" id="ops-console-list-error"></div>
      <table>
        <thead>
          <tr>
            <th>lineUserId</th>
            <th>readiness</th>
            <th>recommendedNextAction</th>
            <th>allowedNextActions</th>
            <th>opsState.nextAction</th>
            <th>latestDecisionLog</th>
            <th>LLM suggestion</th>
            <th>詳細</th>
          </tr>
        </thead>
        <tbody id="ops-console-list-rows"></tbody>
      </table>
    </div>

    <div class="section" id="ops-console-detail-section">
      <h2>Ops Console 詳細</h2>
      <div class="note">lineUserId: <span id="ops-console-detail-line-user-id">-</span></div>
      <div class="note">servicePhase（サービス提供phase SSOT）: <span id="ops-console-detail-service-phase">-</span></div>
      <div class="note">notificationPreset（SSOT）: <span id="ops-console-detail-notification-preset">-</span></div>
      <div class="note">notificationCaps.perUserWeeklyCap（SSOT）: <span id="ops-console-detail-notification-cap-weekly">-</span></div>
      <div class="note" id="ops-console-detail-error"></div>
      <div class="note">
        traceId:
        <a href="#trace-search" id="ops-console-detail-trace-id">-</a>
        / viewAuditId: <span id="ops-console-detail-view-audit-id">-</span>
      </div>
      <div>
        readiness.status:
        <span id="ops-console-detail-readiness-status">-</span>
        <span id="ops-console-detail-danger-badge" class="badge">-</span>
      </div>
      <div>
        riskLevel:
        <span id="ops-console-detail-risk-level">-</span>
        <span id="ops-console-detail-risk-badge" class="badge">-</span>
      </div>
      <div>blockingReasons: <span id="ops-console-detail-blocking-reasons">-</span></div>
      <div>lastReactionAt（LINE定義）: <span id="ops-console-detail-last-reaction-at">-</span></div>
      <div>stopReason: <span id="ops-console-detail-stop-reason">-</span></div>
      <div>execution: <span id="ops-console-detail-execution-message">-</span></div>
      <div>latestDecisionSummary:</div>
      <pre id="ops-console-detail-latest-decision-summary">-</pre>
      <div>recommendedNextAction: <span id="ops-console-detail-recommended">-</span></div>
      <div>allowedNextActions: <span id="ops-console-detail-allowed">-</span></div>
      <div>readiness:</div>
      <pre id="ops-console-detail-readiness">-</pre>
      <div>opsState:</div>
      <pre id="ops-console-detail-ops-state">-</pre>
      <div>latestDecisionLog:</div>
      <pre id="ops-console-detail-latest-decision">-</pre>
      <div>userStateSummary:</div>
      <pre id="ops-console-detail-user-summary">-</pre>
      <div>memberSummary:</div>
      <pre id="ops-console-detail-member-summary">-</pre>
      <div>Redac（derived）: <span id="ops-console-detail-redac-status">-</span></div>
      <div>llmSuggestion:</div>
      <pre id="ops-console-detail-llm-suggestion">-</pre>
      <div>suggestion(schema):</div>
      <pre id="ops-console-detail-suggestion-schema">-</pre>
      <div>lastSuggestionAuditId: <span id="ops-console-detail-suggestion-audit-id">-</span></div>
      <div>llmSuggestion summary:</div>
      <div>suggestedNextAction: <span id="ops-console-detail-suggested-action">-</span></div>
      <div>safety:</div>
      <pre id="ops-console-detail-safety">-</pre>
      <div>evidence:</div>
      <pre id="ops-console-detail-evidence">-</pre>
      <div>phase39Suggestion:</div>
      <pre id="ops-console-detail-phase39-suggestion">-</pre>
      <div>phase39AuditId: <span id="ops-console-detail-phase39-audit-id">-</span></div>

      <h3>Notification Health（add-only）</h3>
      <div class="note">通知の sent/click/read をSSOT（notification_deliveries）から再計算した read-model に基づく（表示のみ）。</div>
      <div>notificationHealthSummary:</div>
      <pre id="ops-console-detail-notification-health-summary">-</pre>
      <div>topUnhealthyNotifications:</div>
      <pre id="ops-console-detail-top-unhealthy">-</pre>
      <div>mitigationSuggestion（advisory）:</div>
      <pre id="ops-console-detail-mitigation-suggestion">-</pre>

      <h3>Ops Decision Submit</h3>
      <div class="note">allowedNextActions のみ選択可。</div>
      <div class="note">
        nextAction:
        <select id="ops-decision-action"></select>
        failure_class:
        <select id="ops-decision-failure-class">
          <option value="PASS">PASS</option>
          <option value="ENV">ENV</option>
          <option value="IMPL">IMPL</option>
          <option value="CONFIG">CONFIG</option>
          <option value="UNKNOWN" selected>UNKNOWN</option>
        </select>
      </div>
      <div class="note">
        reasonCode: <input type="text" id="ops-decision-reason-code" />
        stage: <input type="text" id="ops-decision-stage" />
      </div>
      <div class="note">
        note: <input type="text" id="ops-decision-note" />
        <button class="btn" id="ops-decision-submit">submit</button>
      </div>
      <div class="note">
        <button class="btn" id="ops-decision-use-suggestion">Use Suggestion</button>
        <span id="ops-decision-use-suggestion-note"></span>
      </div>
      <div class="note">
        notification mitigation decision（advisory）:
        <select id="ops-mitigation-decision">
          <option value="">(no record)</option>
          <option value="SKIP">SKIP</option>
          <option value="ADOPT">ADOPT</option>
          <option value="REJECT">REJECT</option>
        </select>
        note: <input type="text" id="ops-mitigation-note" />
      </div>
      <pre id="ops-decision-result">-</pre>
    </div>

    <div class="section" id="segment-send-section">
      <h2>Segment Send（Plan / Execute）</h2>
      <div class="note">Plan/Execute は人間操作。送信自体は Phase68 のガードに従う。</div>
      <div class="note">
        templateKey:
        <input type="text" id="segment-template-key" />
        templateVersion:
        <input type="number" id="segment-template-version" min="1" />
        savedSegment:
        <select id="saved-segment-select"></select>
        readiness:
        <select id="segment-readiness">
          <option value="">ALL</option>
          <option value="READY">READY</option>
          <option value="NOT_READY">NOT_READY</option>
        </select>
        needsAttention:
        <input type="checkbox" id="segment-needs-attention" />
        hasMemberNumber:
        <select id="segment-has-member-number">
          <option value="any">any</option>
          <option value="true">yes</option>
          <option value="false">no</option>
        </select>
        redacStatus:
        <select id="segment-redac-status">
          <option value="any">any</option>
          <option value="DECLARED">declared</option>
          <option value="UNLINKED">unlinked</option>
          <option value="NONE">none</option>
        </select>
        limit:
        <input type="number" id="segment-limit" min="1" max="200" value="50" />
        <button class="btn" id="segment-plan">Plan</button>
        <button class="btn" id="segment-dryrun">Dry-run</button>
        <button class="btn" id="segment-execute">Execute</button>
      </div>
      <div class="note" id="segment-plan-note"></div>
      <pre id="segment-plan-result">-</pre>
      <div class="note" id="segment-dryrun-note"></div>
      <pre id="segment-dryrun-result">-</pre>
      <div class="note" id="segment-execute-note"></div>
      <pre id="segment-execute-result">-</pre>
    </div>

    <div class="section" id="retry-queue-section">
      <h2>Send Retry Queue（READ ONLY + Manual Retry）</h2>
      <div class="note">PENDING の再送キュー一覧。危険操作（retry）は plan → confirmToken → retry を固定する。</div>
      <div class="note">
        limit:
        <input type="number" id="retry-queue-limit" min="1" max="200" value="50" />
        <button class="btn" id="retry-queue-refresh">更新</button>
      </div>
      <div class="note" id="retry-queue-note"></div>
      <div class="note" id="retry-queue-error"></div>
      <table>
        <thead>
          <tr>
            <th>queueId</th>
            <th>lineUserId</th>
            <th>templateKey</th>
            <th>status</th>
            <th>lastError</th>
            <th>updatedAt</th>
            <th>操作</th>
          </tr>
        </thead>
        <tbody id="retry-queue-rows"></tbody>
      </table>
      <pre id="retry-queue-result">-</pre>
    </div>

    <div class="section">
      <h2>memberNumber 未入力（14日超）</h2>
      <div class="note" id="member-stale-count"></div>
      <table>
        <thead>
          <tr>
            <th>lineUserId</th>
            <th>createdAt</th>
            <th>daysSinceCreated</th>
          </tr>
        </thead>
        <tbody id="member-stale-rows"></tbody>
      </table>
    </div>

    <div class="section">
      <h2>Last reviewed</h2>
      <div class="note">手動入力のみ（閲覧や集計では更新しない）</div>
      <div>At: <span id="ops-review-at">-</span></div>
      <div>By: <span id="ops-review-by">-</span></div>
    </div>

    <div class="section" id="implementation-targets">
      <h2>Implementation Targets</h2>
      <div class="note">READ ONLY（参照のみ）</div>
      <table>
        <thead>
          <tr>
            <th>id</th>
            <th>name</th>
            <th>tag</th>
            <th>status</th>
          </tr>
        </thead>
        <tbody id="implementation-targets-rows"></tbody>
      </table>
    </div>

    <script>
      let opsConsoleListCache = [];
      let opsConsoleDetailCache = null;
      let opsConsoleAssistCache = {};
      let selectedOpsConsoleLineUserId = null;
      let selectedOpsConsoleTraceId = null;
      let selectedOpsConsoleServerTime = null;
      let lastOpsSuggestion = null;
      let lastSuggestionUsed = false;
	      let lastMitigationSuggestion = null;
	      let lastTopUnhealthyNotifications = [];
	      let segmentSendPlanCache = null;
	      let segmentSendDryRunCache = null;
	      let segmentSendTraceIdCache = null;
	      let retryQueueCache = [];
	      let retryQueuePlanCache = {};
	      let savedSegmentsCache = [];
	      let selectedSegmentCache = null;

      function clearChildren(node) {
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
      }

      function setText(node, value) {
        if (!node) return;
        node.textContent = value === undefined || value === null ? '-' : String(value);
      }

      function formatJson(value) {
        if (value === undefined || value === null) return '-';
        return JSON.stringify(value, null, 2);
      }

      function formatSuggestionShort(suggestion) {
        if (!suggestion) return '-';
        if (suggestion.suggestion && suggestion.suggestion.recommendedNextAction) {
          const reason = suggestion.suggestion.reason ? `: ${suggestion.suggestion.reason}` : '';
          return `${suggestion.suggestion.recommendedNextAction}${reason}`;
        }
        if (suggestion.suggestion && suggestion.suggestion.nextAction) {
          const reason = suggestion.suggestion.reason ? `: ${suggestion.suggestion.reason}` : '';
          return `${suggestion.suggestion.nextAction}${reason}`;
        }
        if (typeof suggestion.suggestionText === 'string') return suggestion.suggestionText;
        return '-';
      }

      function extractSuggestedAction(suggestion) {
        if (!suggestion) return null;
        if (suggestion.suggestion && suggestion.suggestion.recommendedNextAction) {
          return suggestion.suggestion.recommendedNextAction;
        }
        if (suggestion.suggestion && suggestion.suggestion.nextAction) {
          return suggestion.suggestion.nextAction;
        }
        if (typeof suggestion.recommendedNextAction === 'string') return suggestion.recommendedNextAction;
        return null;
      }

      function buildRangeQuery(prefix) {
        const from = document.getElementById(`${prefix}-from`).value;
        const to = document.getElementById(`${prefix}-to`).value;
        const params = new URLSearchParams();
        if (from) params.set('from', from);
        if (to) params.set('to', to);
        const qs = params.toString();
        return qs ? `?${qs}` : '';
      }

      function buildUsersQuery() {
        const params = new URLSearchParams();
        const from = document.getElementById('users-from').value;
        const to = document.getElementById('users-to').value;
        if (from) params.set('from', from);
        if (to) params.set('to', to);

        if (document.getElementById('filter-needsAttention').checked) {
          params.set('needsAttention', '1');
        }
        if (document.getElementById('filter-stale').checked) {
          params.set('stale', '1');
        }
        if (document.getElementById('filter-unreviewed').checked) {
          params.set('unreviewed', '1');
        }
        const reviewAgeDays = document.getElementById('filter-reviewAgeDays').value;
        if (reviewAgeDays) {
          params.set('reviewAgeDays', reviewAgeDays);
        }

        const qs = params.toString();
        return qs ? `?${qs}` : '';
      }

      function hydrateUsersFilters() {
        const params = new URLSearchParams(location.search);
        const from = params.get('from');
        const to = params.get('to');
        if (from) document.getElementById('users-from').value = from;
        if (to) document.getElementById('users-to').value = to;

        document.getElementById('filter-needsAttention').checked = params.get('needsAttention') === '1';
        document.getElementById('filter-stale').checked = params.get('stale') === '1';
        document.getElementById('filter-unreviewed').checked = params.get('unreviewed') === '1';
        const reviewAgeDays = params.get('reviewAgeDays');
        if (reviewAgeDays) document.getElementById('filter-reviewAgeDays').value = reviewAgeDays;
      }

      function syncUsersQueryToUrl() {
        const params = new URLSearchParams(location.search);
        const from = document.getElementById('users-from').value;
        const to = document.getElementById('users-to').value;
        if (from) params.set('from', from); else params.delete('from');
        if (to) params.set('to', to); else params.delete('to');
        const lineUserId = params.get('lineUserId');
        if (lineUserId) params.set('lineUserId', lineUserId);

        const needsAttention = document.getElementById('filter-needsAttention').checked;
        const stale = document.getElementById('filter-stale').checked;
        const unreviewed = document.getElementById('filter-unreviewed').checked;
        const reviewAgeDays = document.getElementById('filter-reviewAgeDays').value;

        if (needsAttention) params.set('needsAttention', '1'); else params.delete('needsAttention');
        if (stale) params.set('stale', '1'); else params.delete('stale');
        if (unreviewed) params.set('unreviewed', '1'); else params.delete('unreviewed');
        if (reviewAgeDays) params.set('reviewAgeDays', reviewAgeDays); else params.delete('reviewAgeDays');

        const qs = params.toString();
        const nextUrl = qs ? `${location.pathname}?${qs}` : location.pathname;
        history.replaceState(null, '', nextUrl);
      }

      function renderTableMessage(rows, colSpan, message) {
        clearChildren(rows);
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = colSpan;
        td.textContent = message;
        tr.appendChild(td);
        rows.appendChild(tr);
      }

      async function loadUsers() {
        const res = await fetch(`/api/phase5/ops/users-summary${buildUsersQuery()}`);
        const data = await res.json();
        const rows = document.getElementById('users-rows');
        const note = document.getElementById('user-summary-note');
        renderReview(data.review);
        if (!data.ok) {
          renderTableMessage(rows, 9, 'error');
          return;
        }
        if (!data.items.length) {
          renderTableMessage(rows, 9, 'no data');
          return;
        }
        clearChildren(rows);
        data.items.forEach((item) => {
          const tr = document.createElement('tr');

          const cells = [
            item.lineUserId,
            item.hasMemberNumber ? 'あり' : 'なし',
            `${item.checklistCompleted}/${item.checklistTotal}`,
            item.stale ? 'Yes' : 'No',
            item.needsAttention ? 'Yes' : 'No',
            item.opsReviewLastReviewedAt || '-',
            item.opsReviewLastReviewedBy || '-',
            item.lastActionAt || '-'
          ];
          cells.forEach((value) => {
            const td = document.createElement('td');
            td.textContent = value;
            tr.appendChild(td);
          });

          const actionTd = document.createElement('td');
          const btn = document.createElement('button');
          btn.className = 'btn';
          btn.textContent = 'Reviewed';
          btn.addEventListener('click', async () => {
            const lineUserId = item.lineUserId;
            if (!lineUserId) return;
            await fetch('/api/phase5/admin/users/review', {
              method: 'POST',
              headers: { 'content-type': 'application/json; charset=utf-8' },
              body: JSON.stringify({ lineUserId })
            });
            await loadUsers();
          });
          actionTd.appendChild(btn);
          tr.appendChild(actionTd);

          rows.appendChild(tr);
        });

        const params = new URLSearchParams(location.search);
        const lineUserId = params.get('lineUserId');
        if (!lineUserId) {
          note.textContent = 'lineUserId を指定すると個別の状態サマリを表示します';
          return;
        }
        const summaryRes = await fetch(`/api/phase5/state/summary?lineUserId=${encodeURIComponent(lineUserId)}`);
        const summary = await summaryRes.json();
        if (summary.ok && summary.item) {
          const item = summary.item;
          note.textContent = `summary: ${item.lineUserId} / memberNumber: ${item.hasMemberNumber ? 'あり' : 'なし'} / checklist: ${item.checklistCompleted}/${item.checklistTotal} / lastActionAt: ${item.lastActionAt || '-'}`;
        } else {
          note.textContent = 'summary: unavailable';
        }
      }

      async function loadNotifications() {
        const res = await fetch(`/api/phase5/ops/notifications-summary${buildRangeQuery('notifications')}`);
        const data = await res.json();
        const rows = document.getElementById('notifications-rows');
        if (!data.ok) {
          renderTableMessage(rows, 6, 'error');
          return;
        }
        if (!data.items.length) {
          renderTableMessage(rows, 6, 'no data');
          return;
        }
        clearChildren(rows);
        data.items.forEach((item) => {
          const tr = document.createElement('tr');
          const cells = [
            item.notificationId,
            item.sentAt || '-',
            String(item.openCount),
            String(item.clickCount),
            item.lastReactionAt || '-'
          ];
          cells.forEach((value) => {
            const td = document.createElement('td');
            td.textContent = value;
            tr.appendChild(td);
          });
          const actionTd = document.createElement('td');
          const btn = document.createElement('button');
          btn.className = 'btn';
          btn.disabled = true;
          btn.textContent = '詳細を見る';
          actionTd.appendChild(btn);
          tr.appendChild(actionTd);
          rows.appendChild(tr);
        });
      }

      function renderOpsDashboard(items) {
        const rows = document.getElementById('ops-dashboard-rows');
        clearChildren(rows);
        if (!items || !items.length) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 5;
          td.textContent = 'no data';
          tr.appendChild(td);
          rows.appendChild(tr);
          return;
        }
        items.forEach((item) => {
          const tr = document.createElement('tr');
          const cells = [
            item.lineUserId,
            item.memberNumber || '-',
            item.lastDelivery ? JSON.stringify(item.lastDelivery) : '-',
            item.lastNoticeSent ? JSON.stringify(item.lastNoticeSent) : '-',
            item.latestDecisionLog ? JSON.stringify(item.latestDecisionLog) : '-'
          ];
          cells.forEach((value) => {
            const td = document.createElement('td');
            td.textContent = value;
            tr.appendChild(td);
          });
          rows.appendChild(tr);
        });
      }

      async function loadOpsDashboard() {
        const note = document.getElementById('ops-dashboard-note');
        const errorEl = document.getElementById('ops-dashboard-error');
        setText(errorEl, '');
        const limitValue = document.getElementById('ops-dashboard-limit').value;
        const limit = limitValue ? Number(limitValue) : 20;
        try {
          const data = await fetchOpsDashboard(limit);
          if (!data || !data.ok) {
            setText(errorEl, 'error');
            renderOpsDashboard([]);
            return;
          }
          setText(note, `serverTime: ${data.serverTime || '-'}`);
          renderOpsDashboard(Array.isArray(data.items) ? data.items : []);
        } catch (err) {
          setText(errorEl, 'error');
          renderOpsDashboard([]);
        }
      }

      async function loadStaleMemberNumber() {
        const res = await fetch('/api/phase5/ops/member-number-stale');
        const data = await res.json();
        const countEl = document.getElementById('member-stale-count');
        const rows = document.getElementById('member-stale-rows');
        if (!data.ok) {
          countEl.textContent = 'error';
          renderTableMessage(rows, 3, 'error');
          return;
        }
        countEl.textContent = `count: ${data.count}`;
        if (!data.items.length) {
          renderTableMessage(rows, 3, 'none');
          return;
        }
        clearChildren(rows);
        data.items.forEach((item) => {
          const tr = document.createElement('tr');
          const cells = [
            item.lineUserId,
            item.createdAt || '-',
            String(item.daysSinceCreated)
          ];
          cells.forEach((value) => {
            const td = document.createElement('td');
            td.textContent = value;
            tr.appendChild(td);
          });
          rows.appendChild(tr);
        });
      }

      function renderReview(review) {
        const atEl = document.getElementById('ops-review-at');
        const byEl = document.getElementById('ops-review-by');
        if (!atEl || !byEl) return;
        if (!review || !review.lastReviewedAt || !review.lastReviewedBy) {
          atEl.textContent = '-';
          byEl.textContent = '-';
          return;
        }
        atEl.textContent = review.lastReviewedAt;
        byEl.textContent = review.lastReviewedBy;
      }

      async function loadImplementationTargets() {
        const res = await fetch('/admin/implementation-targets');
        const rows = document.getElementById('implementation-targets-rows');
        const data = await res.json();
        if (!Array.isArray(data)) {
          renderTableMessage(rows, 4, 'error');
          return;
        }
        if (!data.length) {
          renderTableMessage(rows, 4, 'no data');
          return;
        }
        clearChildren(rows);
        data.forEach((item) => {
          const tr = document.createElement('tr');
          const cells = [
            item.id,
            item.name || '-',
            item.tag || '-',
            item.status || '-'
          ];
          cells.forEach((value) => {
            const td = document.createElement('td');
            td.textContent = value;
            tr.appendChild(td);
          });
          rows.appendChild(tr);
        });
      }

      const OPS_ACTOR_HEADERS = { 'x-actor': 'ops_readonly' };
      const OPS_TRACE_HEADER_NAME = 'x-trace-id';
      let killSwitchPlanCache = null;

      function newTraceId(prefix) {
        const p = prefix || 'trace';
        try {
          if (globalThis.crypto && typeof globalThis.crypto.randomUUID === 'function') {
            return `${p}-${globalThis.crypto.randomUUID()}`;
          }
        } catch (_err) {}
        return `${p}-${Date.now()}-${Math.floor(Math.random() * 1e9)}`;
      }

      async function fetchOpsConsoleList(limit) {
        const params = new URLSearchParams();
        if (limit) params.set('limit', String(limit));
        const qs = params.toString();
        const res = await fetch(`/api/phase26/ops-console/list${qs ? `?${qs}` : ''}`, { headers: OPS_ACTOR_HEADERS });
        return res.json();
      }

      async function fetchOpsConsoleDetail(lineUserId) {
        const res = await fetch(`/api/phase25/ops/console?lineUserId=${encodeURIComponent(lineUserId)}`, {
          headers: OPS_ACTOR_HEADERS
        });
        return res.json();
      }

      async function fetchOpsDashboard(limit) {
        const params = new URLSearchParams();
        if (limit) params.set('limit', String(limit));
        const qs = params.toString();
        const res = await fetch(`/api/phase38/ops/dashboard${qs ? `?${qs}` : ''}`, { headers: OPS_ACTOR_HEADERS });
        return res.json();
      }

      async function fetchOpsAssistDetail(lineUserId) {
        const res = await fetch(
          `/api/phase42/ops-console/view?lineUserId=${encodeURIComponent(lineUserId)}&includeAssist=1`,
          { headers: OPS_ACTOR_HEADERS }
        );
        return res.json();
      }

      async function fetchPhase39Suggestion(lineUserId) {
        const res = await fetch(
          `/api/phase39/ops-assist/suggestion?lineUserId=${encodeURIComponent(lineUserId)}`,
          { headers: OPS_ACTOR_HEADERS }
        );
        return res.json();
      }

      async function submitOpsDecisionRequest(payload) {
        const res = await fetch('/api/phase25/ops/decision', {
          method: 'POST',
          headers: Object.assign({ 'content-type': 'application/json; charset=utf-8' }, OPS_ACTOR_HEADERS),
          body: JSON.stringify(payload)
        });
        return res.json();
      }

      async function fetchTraceBundle(traceId, limit) {
        const params = new URLSearchParams();
        params.set('traceId', traceId);
        if (limit) params.set('limit', String(limit));
        const res = await fetch(`/api/admin/trace?${params.toString()}`, { headers: OPS_ACTOR_HEADERS });
        return res.json();
      }

      async function submitOpsAssistAdopt(payload) {
        const res = await fetch('/api/phase105/ops-assist/adopt', {
          method: 'POST',
          headers: Object.assign({ 'content-type': 'application/json; charset=utf-8' }, OPS_ACTOR_HEADERS),
          body: JSON.stringify(payload)
        });
        return res.json();
      }

	      async function fetchSegmentPlan(payload) {
	        const traceId = segmentSendTraceIdCache || newTraceId('segment-send');
	        const res = await fetch('/api/phase67/send/plan', {
	          method: 'POST',
	          headers: Object.assign(
	            { 'content-type': 'application/json; charset=utf-8', [OPS_TRACE_HEADER_NAME]: traceId },
	            OPS_ACTOR_HEADERS
	          ),
	          body: JSON.stringify(payload)
	        });
	        const data = await res.json();
	        if (data && data.ok && !data.traceId) data.traceId = traceId;
	        return data;
	      }

	      async function fetchSegmentExecute(payload) {
	        const traceId = segmentSendTraceIdCache || newTraceId('segment-send');
	        const res = await fetch('/api/phase68/send/execute', {
	          method: 'POST',
	          headers: Object.assign(
	            { 'content-type': 'application/json; charset=utf-8', [OPS_TRACE_HEADER_NAME]: traceId },
	            OPS_ACTOR_HEADERS
	          ),
	          body: JSON.stringify(payload)
	        });
	        const data = await res.json();
	        if (data && data.ok && !data.traceId) data.traceId = traceId;
	        return data;
	      }

	      async function fetchSegmentDryRun(payload) {
	        const traceId = segmentSendTraceIdCache || newTraceId('segment-send');
	        const res = await fetch('/api/phase81/segment-send/dry-run', {
	          method: 'POST',
	          headers: Object.assign(
	            { 'content-type': 'application/json; charset=utf-8', [OPS_TRACE_HEADER_NAME]: traceId },
	            OPS_ACTOR_HEADERS
	          ),
	          body: JSON.stringify(payload)
	        });
	        const data = await res.json();
	        if (data && data.ok && !data.traceId) data.traceId = traceId;
	        return data;
	      }

      async function fetchRetryQueue(limit) {
        const params = new URLSearchParams();
        if (limit) params.set('limit', String(limit));
        const qs = params.toString();
        const res = await fetch(`/api/phase73/retry-queue${qs ? `?${qs}` : ''}`, { headers: OPS_ACTOR_HEADERS });
        return res.json();
      }

      async function planRetryQueue(payload) {
        const traceId = newTraceId('retry-queue');
        const res = await fetch('/api/phase73/retry-queue/plan', {
          method: 'POST',
          headers: Object.assign(
            { 'content-type': 'application/json; charset=utf-8', [OPS_TRACE_HEADER_NAME]: traceId },
            OPS_ACTOR_HEADERS
          ),
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (data && data.ok && !data.traceId) data.traceId = traceId;
        return data;
      }

      async function fetchSavedSegments() {
        const res = await fetch('/api/phase77/segments?status=active', { headers: OPS_ACTOR_HEADERS });
        return res.json();
      }

      async function retryQueueSend(payload) {
        const traceId = payload && payload.traceId ? payload.traceId : newTraceId('retry-queue');
        const res = await fetch('/api/phase73/retry-queue/retry', {
          method: 'POST',
          headers: Object.assign(
            { 'content-type': 'application/json; charset=utf-8', [OPS_TRACE_HEADER_NAME]: traceId },
            OPS_ACTOR_HEADERS
          ),
          body: JSON.stringify(payload)
        });
        return res.json();
      }

      async function fetchKillSwitchStatus() {
        const res = await fetch('/api/admin/os/kill-switch/status', { headers: OPS_ACTOR_HEADERS });
        return res.json();
      }

      async function planKillSwitch(isOn) {
        const traceId = newTraceId('kill-switch');
        const res = await fetch('/api/admin/os/kill-switch/plan', {
          method: 'POST',
          headers: Object.assign(
            { 'content-type': 'application/json; charset=utf-8', [OPS_TRACE_HEADER_NAME]: traceId },
            OPS_ACTOR_HEADERS
          ),
          body: JSON.stringify({ isOn: Boolean(isOn) })
        });
        return res.json();
      }

      async function setKillSwitchPlanned(plan) {
        const payload = plan || {};
        const traceId = payload.traceId || newTraceId('kill-switch');
        const res = await fetch('/api/admin/os/kill-switch/set', {
          method: 'POST',
          headers: Object.assign(
            { 'content-type': 'application/json; charset=utf-8', [OPS_TRACE_HEADER_NAME]: traceId },
            OPS_ACTOR_HEADERS
          ),
          body: JSON.stringify({
            isOn: payload.isOn,
            planHash: payload.planHash,
            confirmToken: payload.confirmToken
          })
        });
        return res.json();
      }

      function renderKillSwitchSummary(summary) {
        const stateEl = document.getElementById('kill-switch-state');
        const planHashEl = document.getElementById('kill-switch-plan-hash');
        const tokenEl = document.getElementById('kill-switch-confirm-token');
        const resultEl = document.getElementById('kill-switch-result');
        if (!summary) {
          setText(stateEl, '-');
          setText(planHashEl, '-');
          setText(tokenEl, '-');
          setText(resultEl, 'error');
          return;
        }
        if (summary.ok && typeof summary.killSwitch === 'boolean') {
          setText(stateEl, summary.killSwitch ? 'ON' : 'OFF');
        }
        if (summary.ok && summary.planHash) setText(planHashEl, summary.planHash);
        if (summary.ok && summary.confirmToken) setText(tokenEl, 'set');
        setText(resultEl, formatJson(summary));
      }

      async function loadKillSwitchStatus() {
        const data = await fetchKillSwitchStatus();
        renderKillSwitchSummary(data);
        return data;
      }

      async function handleKillSwitchPlan(isOn) {
        const data = await planKillSwitch(isOn);
        if (data && data.ok) {
          killSwitchPlanCache = {
            traceId: data.traceId || null,
            isOn: Boolean(data.isOn),
            planHash: data.planHash || null,
            confirmToken: data.confirmToken || null
          };
        } else {
          killSwitchPlanCache = null;
        }
        renderKillSwitchSummary(data);
        return data;
      }

      async function handleKillSwitchSet() {
        if (!killSwitchPlanCache || !killSwitchPlanCache.planHash || !killSwitchPlanCache.confirmToken) {
          renderKillSwitchSummary({ ok: false, error: 'plan required' });
          return { ok: false, error: 'plan required' };
        }
        const data = await setKillSwitchPlanned(killSwitchPlanCache);
        renderKillSwitchSummary(data);
        await loadKillSwitchStatus();
        return data;
      }

      function renderOpsConsoleList(items) {
        const rows = document.getElementById('ops-console-list-rows');
        clearChildren(rows);
        if (!items.length) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 8;
          td.textContent = 'no data';
          tr.appendChild(td);
          rows.appendChild(tr);
          return;
        }
        items.forEach((item) => {
          const tr = document.createElement('tr');
          const cells = [
            item.lineUserId,
            item.readiness && item.readiness.status ? item.readiness.status : '-',
            item.recommendedNextAction || '-',
            Array.isArray(item.allowedNextActions) ? item.allowedNextActions.join(', ') : '-',
            item.opsState && item.opsState.nextAction ? item.opsState.nextAction : '-',
            item.latestDecisionLog ? JSON.stringify(item.latestDecisionLog) : '-'
          ];
          cells.forEach((value) => {
            const td = document.createElement('td');
            td.textContent = value;
            tr.appendChild(td);
          });
          const suggestionTd = document.createElement('td');
          suggestionTd.textContent = '-';
          tr.appendChild(suggestionTd);
          loadOpsAssistSummaryForRow(item.lineUserId, suggestionTd).catch(() => {});
          const actionTd = document.createElement('td');
          const btn = document.createElement('button');
          btn.className = 'btn';
          btn.textContent = '詳細';
          btn.dataset.lineUserId = item.lineUserId;
          btn.addEventListener('click', async (event) => {
            const targetId = event.currentTarget.dataset.lineUserId;
            if (!targetId) return;
            await loadOpsConsoleDetail(targetId);
          });
          actionTd.appendChild(btn);
          tr.appendChild(actionTd);
          rows.appendChild(tr);
        });
      }

      function updateDecisionActionOptions(detail) {
        const select = document.getElementById('ops-decision-action');
        clearChildren(select);
        const readinessStatus = detail && detail.readiness ? detail.readiness.status : null;
        let allowed = Array.isArray(detail && detail.allowedNextActions) ? detail.allowedNextActions.slice() : [];
        if (readinessStatus === 'NOT_READY') {
          allowed = ['STOP_AND_ESCALATE'];
        }
        if (!allowed.length) {
          allowed = ['STOP_AND_ESCALATE'];
        }
        allowed.forEach((action) => {
          const option = document.createElement('option');
          option.value = action;
          option.textContent = action;
          select.appendChild(option);
        });
        if (detail && detail.recommendedNextAction && allowed.includes(detail.recommendedNextAction)) {
          select.value = detail.recommendedNextAction;
        }
      }

      function renderOpsConsoleDetail(detail) {
        setText(document.getElementById('ops-console-detail-line-user-id'), detail.lineUserId || '-');
        const servicePhaseValue = detail.servicePhase === null || detail.servicePhase === undefined
          ? null
          : String(detail.servicePhase);
        setText(document.getElementById('ops-console-detail-service-phase'), servicePhaseValue || '-');
        setText(document.getElementById('ops-console-detail-notification-preset'), detail.notificationPreset || '-');
        const capWeekly = detail.notificationCaps && detail.notificationCaps.perUserWeeklyCap !== null && detail.notificationCaps.perUserWeeklyCap !== undefined
          ? String(detail.notificationCaps.perUserWeeklyCap)
          : null;
        setText(document.getElementById('ops-console-detail-notification-cap-weekly'), capWeekly || '-');
        selectedOpsConsoleTraceId = detail.traceId || null;
        selectedOpsConsoleServerTime = detail.serverTime || null;
        setText(document.getElementById('ops-console-detail-trace-id'), detail.traceId || '-');
        setText(document.getElementById('ops-console-detail-view-audit-id'), detail.viewAuditId || '-');
        setText(document.getElementById('ops-console-detail-readiness-status'), detail.readinessStatus || '-');
        setText(
          document.getElementById('ops-console-detail-blocking-reasons'),
          Array.isArray(detail.blockingReasons) && detail.blockingReasons.length ? detail.blockingReasons.join(', ') : '-'
        );
        setText(document.getElementById('ops-console-detail-last-reaction-at'), detail.lastReactionAt || '-');
        setText(document.getElementById('ops-console-detail-stop-reason'), detail.stopReason || '-');
        setText(document.getElementById('ops-console-detail-execution-message'), detail.executionMessage || '-');
        setText(document.getElementById('ops-console-detail-latest-decision-summary'), formatJson(detail.latestDecisionSummary));
        const badge = document.getElementById('ops-console-detail-danger-badge');
        if (badge) {
          badge.className = 'badge';
          if (detail && detail.dangerFlags && detail.dangerFlags.notReady) {
            badge.classList.add('badge-danger');
            badge.textContent = 'DANGER: NOT_READY';
          } else if (detail && detail.dangerFlags && detail.dangerFlags.staleMemberNumber) {
            badge.classList.add('badge-warn');
            badge.textContent = 'WARN: stale';
          } else {
            badge.classList.add('badge-ok');
            badge.textContent = 'OK';
          }
        }
        setText(document.getElementById('ops-console-detail-risk-level'), detail.riskLevel || '-');
        const riskBadge = document.getElementById('ops-console-detail-risk-badge');
        if (riskBadge) {
          riskBadge.className = 'badge';
          if (detail && detail.riskLevel === 'HIGH') {
            riskBadge.classList.add('badge-danger');
            riskBadge.textContent = 'HIGH';
          } else if (detail && detail.riskLevel === 'MEDIUM') {
            riskBadge.classList.add('badge-warn');
            riskBadge.textContent = 'MEDIUM';
          } else {
            riskBadge.classList.add('badge-ok');
            riskBadge.textContent = 'LOW';
          }
        }
        setText(document.getElementById('ops-console-detail-recommended'), detail.recommendedNextAction || '-');
        setText(
          document.getElementById('ops-console-detail-allowed'),
          Array.isArray(detail.allowedNextActions) ? detail.allowedNextActions.join(', ') : '-'
        );
        setText(document.getElementById('ops-console-detail-readiness'), formatJson(detail.readiness));
        setText(document.getElementById('ops-console-detail-ops-state'), formatJson(detail.opsState));
        setText(document.getElementById('ops-console-detail-latest-decision'), formatJson(detail.latestDecisionLog));
        setText(document.getElementById('ops-console-detail-user-summary'), formatJson(detail.userStateSummary));
        setText(document.getElementById('ops-console-detail-member-summary'), formatJson(detail.memberSummary));
        setText(document.getElementById('ops-console-detail-redac-status'), formatRedacStatus(detail.memberSummary));
        setText(
          document.getElementById('ops-console-detail-notification-health-summary'),
          formatJson(detail.notificationHealthSummary || null)
        );
        setText(
          document.getElementById('ops-console-detail-top-unhealthy'),
          formatJson(detail.topUnhealthyNotifications || [])
        );
        setText(
          document.getElementById('ops-console-detail-mitigation-suggestion'),
          formatJson(detail.mitigationSuggestion || null)
        );
        lastMitigationSuggestion = detail.mitigationSuggestion || null;
        lastTopUnhealthyNotifications = Array.isArray(detail.topUnhealthyNotifications) ? detail.topUnhealthyNotifications : [];
        updateDecisionActionOptions(detail);
      }

      function formatRedacStatus(memberSummary) {
        const ms = memberSummary && memberSummary.member ? memberSummary : null;
        const redac = ms && ms.member && ms.member.redac ? ms.member.redac : null;
        const has = Boolean(redac && redac.hasRedacMembership);
        const last4 = redac && typeof redac.redacMembershipIdLast4 === 'string' ? redac.redacMembershipIdLast4 : null;
        const unlinkedAt = redac && redac.redacMembershipUnlinkedAt ? String(redac.redacMembershipUnlinkedAt) : null;
        if (has && last4) return `登録済み (last4=${last4})`;
        if (!has && unlinkedAt) return '解除済み';
        return '未登録';
      }

      function renderOpsAssistDetail(assist) {
        const suggestion = assist ? assist.llmSuggestion : null;
        setText(document.getElementById('ops-console-detail-llm-suggestion'), formatJson(suggestion));
        setText(
          document.getElementById('ops-console-detail-suggestion-schema'),
          formatJson(assist ? assist.suggestion : null)
        );
        setText(
          document.getElementById('ops-console-detail-suggestion-audit-id'),
          assist && assist.lastSuggestionAuditId ? assist.lastSuggestionAuditId : '-'
        );
        setText(document.getElementById('ops-console-detail-suggested-action'), extractSuggestedAction(suggestion));
        setText(document.getElementById('ops-console-detail-safety'), formatJson(suggestion ? suggestion.safety : null));
        setText(document.getElementById('ops-console-detail-evidence'), formatJson(suggestion ? suggestion.evidence : null));
        lastOpsSuggestion = suggestion;
        lastSuggestionUsed = false;
        setText(document.getElementById('ops-decision-use-suggestion-note'), '');
      }

      function renderSavedSegments(items) {
        const select = document.getElementById('saved-segment-select');
        clearChildren(select);
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'manual';
        select.appendChild(defaultOption);
        if (!items.length) return;
        items.forEach((item) => {
          const option = document.createElement('option');
          option.value = item.segmentKey;
          option.textContent = item.label ? `${item.label} (${item.segmentKey})` : item.segmentKey;
          select.appendChild(option);
        });
      }

      function applySegmentFilter(filter) {
        const readinessEl = document.getElementById('segment-readiness');
        const needsAttentionEl = document.getElementById('segment-needs-attention');
        const hasMemberNumberEl = document.getElementById('segment-has-member-number');
        const redacStatusEl = document.getElementById('segment-redac-status');
        const limitEl = document.getElementById('segment-limit');
        if (!filter || typeof filter !== 'object') {
          readinessEl.value = '';
          needsAttentionEl.checked = false;
          hasMemberNumberEl.value = 'any';
          redacStatusEl.value = 'any';
          limitEl.value = 50;
          return;
        }
        readinessEl.value = filter.readinessStatus || '';
        needsAttentionEl.checked = Boolean(filter.needsAttention);
        hasMemberNumberEl.value = filter.hasMemberNumber !== undefined && filter.hasMemberNumber !== null
          ? String(filter.hasMemberNumber)
          : 'any';
        redacStatusEl.value = filter.redacStatus ? String(filter.redacStatus) : 'any';
        if (filter.limit) {
          limitEl.value = Number(filter.limit);
        }
      }

      function buildSegmentQueryFromInputs() {
        const readiness = document.getElementById('segment-readiness').value;
        const needsAttention = document.getElementById('segment-needs-attention').checked;
        const hasMemberNumber = document.getElementById('segment-has-member-number').value;
        const redacStatus = document.getElementById('segment-redac-status').value;
        const limitValue = document.getElementById('segment-limit').value;
        const limit = limitValue ? Number(limitValue) : null;
        const query = {};
        if (readiness) query.readinessStatus = readiness;
        if (needsAttention) query.needsAttention = 1;
        if (hasMemberNumber && hasMemberNumber !== 'any') query.hasMemberNumber = hasMemberNumber;
        if (redacStatus && redacStatus !== 'any') query.redacStatus = redacStatus;
        if (limit) query.limit = limit;
        return query;
      }

	      function renderSegmentPlanResult(result) {
	        const note = document.getElementById('segment-plan-note');
	        const resultEl = document.getElementById('segment-plan-result');
	        if (!result || !result.ok) {
	          setText(note, 'plan error');
          setText(resultEl, formatJson(result || {}));
          return;
	        }
	        const sample = Array.isArray(result.lineUserIds) ? result.lineUserIds.slice(0, 5).join(', ') : '-';
	        const traceId = result.traceId || '-';
	        setText(note, `traceId: ${traceId} / count: ${result.count} / planHash: ${result.planHash || '-'} / sample: ${sample}`);
	        setText(resultEl, formatJson(result));
	      }

	      function renderSegmentDryRunResult(result) {
	        const note = document.getElementById('segment-dryrun-note');
	        const resultEl = document.getElementById('segment-dryrun-result');
	        if (!result || !result.ok) {
	          setText(note, 'dry-run error');
          setText(resultEl, formatJson(result || {}));
          return;
	        }
	        const sample = Array.isArray(result.targetsSample) ? result.targetsSample.join(', ') : '-';
	        const traceId = result.traceId || '-';
	        setText(note, `traceId: ${traceId} / targetCount: ${result.targetCount} / confirmToken: ${result.confirmToken || '-'} / sample: ${sample}`);
	        setText(resultEl, formatJson(result));
	      }

	      function renderSegmentExecuteResult(result) {
	        const note = document.getElementById('segment-execute-note');
	        const resultEl = document.getElementById('segment-execute-result');
	        if (!result) {
	          setText(note, 'execute error');
          setText(resultEl, '-');
          return;
	        }
	        const status = result.ok ? 'ok' : 'error';
	        const failureCount = Array.isArray(result.failures) ? result.failures.length : 0;
	        const traceId = result.traceId || '-';
	        setText(note, `traceId: ${traceId} / result: ${status} / executedCount: ${result.executedCount || 0} / failures: ${failureCount}`);
	        setText(resultEl, formatJson(result));
	      }

      function renderRetryQueue(items) {
        const rows = document.getElementById('retry-queue-rows');
        clearChildren(rows);
        if (!items.length) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 7;
          td.textContent = 'no data';
          tr.appendChild(td);
          rows.appendChild(tr);
          return;
        }
        items.forEach((item) => {
          const tr = document.createElement('tr');
          const cells = [
            item.id || '-',
            item.lineUserId || '-',
            item.templateKey || '-',
            item.status || '-',
            item.lastError || '-',
            item.updatedAt || item.createdAt || '-'
          ];
          cells.forEach((value) => {
            const td = document.createElement('td');
            td.textContent = value;
            tr.appendChild(td);
          });
          const actionTd = document.createElement('td');
          const queueId = item.id || null;
          const planned = queueId && retryQueuePlanCache[queueId] ? retryQueuePlanCache[queueId] : null;

          const planBtn = document.createElement('button');
          planBtn.className = 'btn';
          planBtn.textContent = 'plan';
          planBtn.dataset.queueId = item.id;
          planBtn.addEventListener('click', async (event) => {
            const errorEl = document.getElementById('retry-queue-error');
            const resultEl = document.getElementById('retry-queue-result');
            setText(errorEl, '');
            setText(resultEl, '');
            const qid = event.currentTarget.dataset.queueId;
            if (!qid) return;
            const res = await planRetryQueue({ queueId: qid, decidedBy: 'ops_readonly' });
            setText(resultEl, formatJson(res));
            if (res && res.ok) {
              retryQueuePlanCache[qid] = {
                planHash: res.planHash || null,
                confirmToken: res.confirmToken || null,
                traceId: res.traceId || null
              };
            } else {
              delete retryQueuePlanCache[qid];
            }
            await loadRetryQueue();
          });

          const retryBtn = document.createElement('button');
          retryBtn.className = 'btn';
          retryBtn.textContent = 'retry';
          retryBtn.dataset.queueId = item.id;
          retryBtn.disabled = !planned || !planned.planHash || !planned.confirmToken;
          retryBtn.addEventListener('click', async (event) => {
            const errorEl = document.getElementById('retry-queue-error');
            const resultEl = document.getElementById('retry-queue-result');
            setText(errorEl, '');
            setText(resultEl, '');
            const qid = event.currentTarget.dataset.queueId;
            if (!qid) return;
            const plan = retryQueuePlanCache[qid];
            if (!plan || !plan.planHash || !plan.confirmToken) {
              setText(errorEl, 'plan required');
              return;
            }
            const res = await retryQueueSend({
              queueId: qid,
              planHash: plan.planHash,
              confirmToken: plan.confirmToken,
              traceId: plan.traceId || null,
              decidedBy: 'ops_readonly'
            });
            setText(resultEl, formatJson(res));
            delete retryQueuePlanCache[qid];
            await loadRetryQueue();
          });

          const planState = document.createElement('span');
          planState.textContent = planned && planned.planHash && planned.confirmToken ? ' token:set' : ' token:-';

          actionTd.appendChild(planBtn);
          actionTd.appendChild(document.createTextNode(' '));
          actionTd.appendChild(retryBtn);
          actionTd.appendChild(planState);
          tr.appendChild(actionTd);
          rows.appendChild(tr);
        });
      }

      async function loadOpsConsoleList() {
        const note = document.getElementById('ops-console-list-note');
        const errorEl = document.getElementById('ops-console-list-error');
        setText(errorEl, '');
        const limitValue = document.getElementById('ops-console-limit').value;
        const limit = limitValue ? Number(limitValue) : 20;
        try {
          const data = await fetchOpsConsoleList(limit);
          if (!data || !data.ok) {
            setText(errorEl, 'error');
            renderOpsConsoleList([]);
            return;
          }
          opsConsoleListCache = Array.isArray(data.items) ? data.items : [];
          const pageInfoText = data.pageInfo ? JSON.stringify(data.pageInfo) : '-';
          note.textContent = `serverTime: ${data.serverTime || '-'} / pageInfo: ${pageInfoText} / nextPageToken: ${data.nextPageToken || '-'}`;
          renderOpsConsoleList(opsConsoleListCache);
        } catch (err) {
          setText(errorEl, 'error');
          renderOpsConsoleList([]);
        }
      }

      async function loadOpsConsoleDetail(lineUserId) {
        const errorEl = document.getElementById('ops-console-detail-error');
        setText(errorEl, '');
        selectedOpsConsoleLineUserId = lineUserId;
        setText(document.getElementById('ops-console-detail-line-user-id'), lineUserId || '-');
        try {
          const detail = await fetchOpsConsoleDetail(lineUserId);
          if (!detail || !detail.ok) {
            setText(errorEl, 'error');
            return;
          }
          opsConsoleDetailCache = detail;
          renderOpsConsoleDetail(detail);
          await loadOpsAssistDetail(lineUserId);
          await loadPhase39Suggestion(lineUserId);
        } catch (err) {
          setText(errorEl, 'error');
        }
      }

      async function loadOpsAssistDetail(lineUserId) {
        if (!lineUserId) return;
        try {
          const detail = await fetchOpsAssistDetail(lineUserId);
          if (!detail || !detail.ok) {
            renderOpsAssistDetail(null);
            return;
          }
          opsConsoleAssistCache[lineUserId] = detail;
          renderOpsAssistDetail(detail);
        } catch (err) {
          renderOpsAssistDetail(null);
        }
      }

      async function loadOpsAssistSummaryForRow(lineUserId, cell) {
        if (!lineUserId || !cell) return;
        if (opsConsoleAssistCache[lineUserId]) {
          cell.textContent = formatSuggestionShort(opsConsoleAssistCache[lineUserId].llmSuggestion);
          return;
        }
        const detail = await fetchOpsAssistDetail(lineUserId);
        if (detail && detail.ok) {
          opsConsoleAssistCache[lineUserId] = detail;
          cell.textContent = formatSuggestionShort(detail.llmSuggestion);
          return;
        }
        cell.textContent = '-';
      }

      async function loadPhase39Suggestion(lineUserId) {
        if (!lineUserId) return;
        try {
          const detail = await fetchPhase39Suggestion(lineUserId);
          if (!detail || !detail.ok) {
            setText(document.getElementById('ops-console-detail-phase39-suggestion'), '-');
            setText(document.getElementById('ops-console-detail-phase39-audit-id'), '-');
            return;
          }
          setText(
            document.getElementById('ops-console-detail-phase39-suggestion'),
            formatJson(detail.suggestion)
          );
          setText(
            document.getElementById('ops-console-detail-phase39-audit-id'),
            detail.auditId || '-'
          );
        } catch (err) {
          setText(document.getElementById('ops-console-detail-phase39-suggestion'), '-');
          setText(document.getElementById('ops-console-detail-phase39-audit-id'), '-');
        }
      }

	      async function handleSegmentPlan() {
	        const note = document.getElementById('segment-plan-note');
	        setText(note, '');
	        segmentSendPlanCache = null;
	        segmentSendDryRunCache = null;
	        segmentSendTraceIdCache = newTraceId('segment-send');
	        const templateKey = document.getElementById('segment-template-key').value.trim();
	        const templateVersionValue = document.getElementById('segment-template-version').value;
	        const templateVersion = templateVersionValue ? Number(templateVersionValue) : null;
	        if (!templateKey) {
	          setText(note, 'templateKey required');
          return;
        }
        const segmentQuery = buildSegmentQueryFromInputs();
        const segmentKey = selectedSegmentCache ? selectedSegmentCache.segmentKey : null;
        const filterSnapshot = selectedSegmentCache ? selectedSegmentCache.filter : null;
        const payload = {
          templateKey,
          templateVersion,
          segmentQuery,
          segmentKey,
          filterSnapshot,
          requestedBy: 'ops_readonly'
        };
	        const result = await fetchSegmentPlan(payload);
	        renderSegmentPlanResult(result);
	        if (result && result.ok) {
	          segmentSendPlanCache = {
	            templateKey,
	            traceId: result.traceId || segmentSendTraceIdCache,
	            planHash: result.planHash,
	            segmentQuery,
	            templateVersion: result.templateVersion || templateVersion,
	            segmentKey,
	            filterSnapshot
	          };
	        }
	      }

	      async function handleSegmentDryRun() {
	        const note = document.getElementById('segment-dryrun-note');
	        setText(note, '');
	        segmentSendDryRunCache = null;
	        if (!segmentSendTraceIdCache) segmentSendTraceIdCache = newTraceId('segment-send');
	        const templateKey = document.getElementById('segment-template-key').value.trim();
	        const templateVersionValue = document.getElementById('segment-template-version').value;
	        const templateVersion = templateVersionValue ? Number(templateVersionValue) : null;
        if (!templateKey) {
          setText(note, 'templateKey required');
          return;
        }
        const segmentQuery = buildSegmentQueryFromInputs();
        const segmentKey = selectedSegmentCache ? selectedSegmentCache.segmentKey : null;
        const filterSnapshot = selectedSegmentCache ? selectedSegmentCache.filter : null;
        const payload = {
          templateKey,
          templateVersion,
          segmentQuery,
          segmentKey,
          filterSnapshot,
          requestedBy: 'ops_readonly'
        };
	        const result = await fetchSegmentDryRun(payload);
	        renderSegmentDryRunResult(result);
	        if (result && result.ok) {
	          segmentSendDryRunCache = {
	            traceId: result.traceId || segmentSendTraceIdCache,
	            confirmToken: result.confirmToken,
	            planHash: result.planHash
	          };
	        }
	      }

	      async function handleSegmentExecute() {
	        const note = document.getElementById('segment-execute-note');
	        setText(note, '');
	        if (!segmentSendTraceIdCache) segmentSendTraceIdCache = newTraceId('segment-send');
	        const templateKey = document.getElementById('segment-template-key').value.trim();
	        if (!templateKey) {
	          setText(note, 'templateKey required');
	          return;
        }
        if (!segmentSendPlanCache || !segmentSendPlanCache.planHash) {
          setText(note, 'plan required');
          return;
        }
        if (!segmentSendDryRunCache || !segmentSendDryRunCache.confirmToken) {
          setText(note, 'confirmToken required (run dry-run)');
          return;
        }
        if (segmentSendPlanCache.templateKey && segmentSendPlanCache.templateKey !== templateKey) {
          setText(note, 'plan/template mismatch');
          return;
        }
        const payload = {
          templateKey,
          segmentQuery: segmentSendPlanCache.segmentQuery || {},
          requestedBy: 'ops_readonly',
          planHash: segmentSendPlanCache.planHash,
          templateVersion: segmentSendPlanCache.templateVersion || null,
          segmentKey: segmentSendPlanCache.segmentKey || null,
          filterSnapshot: segmentSendPlanCache.filterSnapshot || null,
          confirmToken: segmentSendDryRunCache.confirmToken
        };
	        const result = await fetchSegmentExecute(payload);
	        renderSegmentExecuteResult(result);
	        // Lock traceId to the returned value (server may normalize/fallback).
	        if (result && result.traceId) segmentSendTraceIdCache = result.traceId;
	        await loadRetryQueue();
	      }

      async function loadRetryQueue() {
        const note = document.getElementById('retry-queue-note');
        const errorEl = document.getElementById('retry-queue-error');
        setText(errorEl, '');
        const limitValue = document.getElementById('retry-queue-limit').value;
        const limit = limitValue ? Number(limitValue) : 50;
        try {
          const data = await fetchRetryQueue(limit);
          if (!data || !data.ok) {
            setText(errorEl, 'error');
            renderRetryQueue([]);
            return;
          }
          retryQueueCache = Array.isArray(data.items) ? data.items : [];
          // Drop plans for items that no longer exist/pending in the current view.
          try {
            const ids = new Set(retryQueueCache.map((it) => it && it.id).filter(Boolean));
            Object.keys(retryQueuePlanCache).forEach((id) => {
              if (!ids.has(id)) delete retryQueuePlanCache[id];
            });
          } catch (_err) {}
          setText(note, `serverTime: ${data.serverTime || '-'}`);
          renderRetryQueue(retryQueueCache);
        } catch (err) {
          setText(errorEl, 'error');
          renderRetryQueue([]);
        }
      }

      async function loadSavedSegments() {
        const select = document.getElementById('saved-segment-select');
        try {
          const data = await fetchSavedSegments();
          if (!data || !data.ok) {
            renderSavedSegments([]);
            return;
          }
          savedSegmentsCache = Array.isArray(data.items) ? data.items : [];
          renderSavedSegments(savedSegmentsCache);
          select.value = '';
          selectedSegmentCache = null;
        } catch (_err) {
          renderSavedSegments([]);
        }
      }

      async function handleSubmitOpsDecision() {
        const resultEl = document.getElementById('ops-decision-result');
        setText(resultEl, '');
        const lineUserId = selectedOpsConsoleLineUserId;
        if (!lineUserId) {
          setText(resultEl, 'lineUserId not selected');
          return;
        }
        const nextAction = document.getElementById('ops-decision-action').value;
        const failureClass = document.getElementById('ops-decision-failure-class').value;
        const reasonCode = document.getElementById('ops-decision-reason-code').value;
        const stage = document.getElementById('ops-decision-stage').value;
        const note = document.getElementById('ops-decision-note').value;
        const mitigationDecisionValue = document.getElementById('ops-mitigation-decision').value;
        const mitigationNote = document.getElementById('ops-mitigation-note').value;
        let notificationMitigationDecision = null;
        if (mitigationDecisionValue) {
          const targetId = lastTopUnhealthyNotifications.length ? lastTopUnhealthyNotifications[0].notificationId : null;
          notificationMitigationDecision = {
            decision: mitigationDecisionValue,
            note: mitigationNote || '',
            actionType: lastMitigationSuggestion ? lastMitigationSuggestion.actionType || null : null,
            targetNotificationId: targetId || null
          };
        }
        const payload = {
          lineUserId,
          traceId: selectedOpsConsoleTraceId,
          safetySnapshot: {
            consoleServerTime: selectedOpsConsoleServerTime,
            maxConsoleAgeMs: 5 * 60 * 1000,
            reason: 'ops_readonly_submit'
          },
          decision: {
            nextAction,
            failure_class: failureClass,
            reasonCode: reasonCode || null,
            stage: stage || null,
            note: note || ''
          },
          notificationMitigationDecision
        };
        try {
          const result = await submitOpsDecisionRequest(payload);
          setText(resultEl, formatJson(result));
          if (result && result.ok) {
            if (lastSuggestionUsed) {
              const suggestedAction = extractSuggestedAction(lastOpsSuggestion);
              if (suggestedAction && suggestedAction === nextAction) {
                try {
                  await submitOpsAssistAdopt({
                    lineUserId,
                    decisionLogId: result.decisionLogId || null,
                    adoptedAction: nextAction,
                    suggestion: lastOpsSuggestion ? lastOpsSuggestion.suggestion || null : null,
                    safety: lastOpsSuggestion ? lastOpsSuggestion.safety || null : null
                  });
                } catch (_err) {
                  // best-effort only
                }
              }
            }
            await loadOpsConsoleDetail(lineUserId);
            await loadOpsConsoleList();
          }
        } catch (err) {
          setText(resultEl, 'error');
        }
        lastSuggestionUsed = false;
      }

      async function handleTraceSearch() {
        const traceId = document.getElementById('trace-search-trace-id').value;
        const limitValue = document.getElementById('trace-search-limit').value;
        const limit = limitValue ? Number(limitValue) : 50;
        const resultEl = document.getElementById('trace-search-result');
        setText(resultEl, '');
        if (!traceId || !String(traceId).trim()) {
          setText(resultEl, 'traceId required');
          return;
        }
        try {
          const data = await fetchTraceBundle(String(traceId).trim(), limit);
          setText(resultEl, formatJson(data));
        } catch (_err) {
          setText(resultEl, 'error');
        }
      }

      document.getElementById('users-apply').addEventListener('click', () => {
        syncUsersQueryToUrl();
        loadUsers().catch(() => {});
      });
      document.getElementById('notifications-apply').addEventListener('click', () => {
        loadNotifications().catch(() => {});
      });
      document.getElementById('trace-search-run').addEventListener('click', () => {
        handleTraceSearch().catch(() => {});
      });
      document.getElementById('ops-console-detail-trace-id').addEventListener('click', () => {
        const traceIdEl = document.getElementById('trace-search-trace-id');
        if (traceIdEl && selectedOpsConsoleTraceId) traceIdEl.value = selectedOpsConsoleTraceId;
        handleTraceSearch().catch(() => {});
      });
      document.getElementById('ops-dashboard-refresh').addEventListener('click', () => {
        loadOpsDashboard().catch(() => {});
      });
      document.getElementById('ops-console-refresh').addEventListener('click', () => {
        loadOpsConsoleList().catch(() => {});
      });
      document.getElementById('ops-decision-submit').addEventListener('click', () => {
        handleSubmitOpsDecision().catch(() => {});
      });
      document.getElementById('ops-decision-use-suggestion').addEventListener('click', () => {
        const noteEl = document.getElementById('ops-decision-use-suggestion-note');
        const action = extractSuggestedAction(lastOpsSuggestion);
        if (!action) {
          setText(noteEl, 'no suggestion');
          lastSuggestionUsed = false;
          return;
        }
        const select = document.getElementById('ops-decision-action');
        if (select) {
          select.value = action;
        }
        lastSuggestionUsed = true;
        setText(noteEl, `selected: ${action}`);
      });
      document.getElementById('segment-plan').addEventListener('click', () => {
        handleSegmentPlan().catch(() => {});
      });
      document.getElementById('segment-dryrun').addEventListener('click', () => {
        handleSegmentDryRun().catch(() => {});
      });
      document.getElementById('segment-execute').addEventListener('click', () => {
        handleSegmentExecute().catch(() => {});
      });
      document.getElementById('retry-queue-refresh').addEventListener('click', () => {
        loadRetryQueue().catch(() => {});
      });
      document.getElementById('saved-segment-select').addEventListener('change', (event) => {
        const key = event.currentTarget.value;
        if (!key) {
          selectedSegmentCache = null;
          return;
        }
        const segment = savedSegmentsCache.find((item) => item.segmentKey === key);
        selectedSegmentCache = segment || null;
        applySegmentFilter(segment ? segment.filter : null);
      });

      document.getElementById('kill-switch-refresh').addEventListener('click', () => {
        loadKillSwitchStatus().catch(() => {});
      });
      document.getElementById('kill-switch-plan-on').addEventListener('click', () => {
        handleKillSwitchPlan(true).catch(() => {});
      });
      document.getElementById('kill-switch-plan-off').addEventListener('click', () => {
        handleKillSwitchPlan(false).catch(() => {});
      });
      document.getElementById('kill-switch-set').addEventListener('click', () => {
        handleKillSwitchSet().catch(() => {});
      });

      hydrateUsersFilters();
      Promise.all([
        loadUsers(),
        loadNotifications(),
        loadOpsDashboard(),
        loadStaleMemberNumber(),
        loadImplementationTargets(),
        loadOpsConsoleList(),
        loadKillSwitchStatus(),
        loadRetryQueue(),
        loadSavedSegments()
      ]).catch(() => {
        renderTableMessage(document.getElementById('users-rows'), 9, 'error');
        renderTableMessage(document.getElementById('notifications-rows'), 6, 'error');
        renderTableMessage(document.getElementById('ops-dashboard-rows'), 5, 'error');
        renderTableMessage(document.getElementById('member-stale-rows'), 3, 'error');
        renderTableMessage(document.getElementById('implementation-targets-rows'), 4, 'error');
      });
    </script>
  </body>
</html>
