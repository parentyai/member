<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>運用判断支援（READ ONLY）</title>
    <style>
      body { font-family: system-ui, sans-serif; margin: 16px; color: #222; }
      table { width: 100%; border-collapse: collapse; margin-bottom: 24px; }
      th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; font-size: 14px; }
      th { background: #f7f7f7; }
      .note { font-size: 12px; color: #666; margin-bottom: 8px; }
      .section { margin-bottom: 24px; }
      .btn { font-size: 12px; padding: 4px 8px; }
      .badge { display: inline-block; padding: 2px 6px; border-radius: 6px; font-size: 12px; }
      .badge-danger { background: #ffe3e3; color: #a40000; }
      .badge-warn { background: #fff4d6; color: #7a4a00; }
      .badge-ok { background: #e6ffed; color: #0f5f2e; }
    </style>
  </head>
  <body>
    <h1>運用判断支援（READ ONLY）</h1>
    <div class="note">表示のみ。判断と操作は人間が行います。</div>
    <div class="note">
      <a href="/admin/read-model">通知集計</a> |
      <a href="#trace-search">Trace Search</a> |
      <a href="#implementation-targets">Implementation Targets</a>
    </div>

    <div class="section" id="trace-search">
      <h2>Trace Search（監査）</h2>
      <div class="note">traceId を入力して audit_logs / decision_logs / decision_timeline を参照。</div>
      <div class="note">
        traceId: <input type="text" id="trace-search-trace-id" style="min-width: 260px" />
        limit: <input type="number" id="trace-search-limit" min="1" max="200" value="50" />
        <button class="btn" id="trace-search-run">検索</button>
      </div>
      <pre id="trace-search-result">-</pre>
    </div>

    <div class="section">
      <h2>ユーザー状態一覧（READ ONLY）</h2>
      <div class="note">期間フィルタ（UTC）</div>
      <div class="note">
        from: <input type="date" id="users-from" />
        to: <input type="date" id="users-to" />
        <button class="btn" id="users-apply">適用</button>
      </div>
      <div class="note">
        <label><input type="checkbox" id="filter-needsAttention" /> needsAttention</label>
        <label><input type="checkbox" id="filter-stale" /> stale</label>
        <label><input type="checkbox" id="filter-unreviewed" /> unreviewed</label>
        <label>reviewAgeDays: <input type="number" id="filter-reviewAgeDays" min="1" max="365" /></label>
      </div>
      <div class="note" id="user-summary-note"></div>
      <table>
        <thead>
          <tr>
            <th>lineUserId</th>
            <th>memberNumber</th>
            <th>checklist</th>
            <th>stale</th>
            <th>needsAttention</th>
            <th>lastReviewedAt</th>
            <th>lastReviewedBy</th>
            <th>lastActionAt</th>
            <th>操作</th>
          </tr>
        </thead>
        <tbody id="users-rows"></tbody>
      </table>
    </div>

    <div class="section">
      <h2>通知状態一覧</h2>
      <div class="note">期間フィルタ（UTC）</div>
      <div class="note">最終反応はLINE-only定義（click優先、readは補助、openは内部イベント扱い）</div>
      <div class="note">
        from: <input type="date" id="notifications-from" />
        to: <input type="date" id="notifications-to" />
        <button class="btn" id="notifications-apply">適用</button>
      </div>
      <table>
        <thead>
          <tr>
            <th>notificationId</th>
            <th>sentAt</th>
            <th>open</th>
            <th>click</th>
            <th>最終反応（LINE定義）</th>
            <th>詳細</th>
          </tr>
        </thead>
        <tbody id="notifications-rows"></tbody>
      </table>
    </div>

    <div class="section" id="ops-dashboard-section">
      <h2>Ops Dashboard（Phase38）</h2>
      <div class="note">ユーザー×通知×notice×decision を一覧で参照。</div>
      <div class="note">
        limit: <input type="number" id="ops-dashboard-limit" min="1" max="200" value="20" />
        <button class="btn" id="ops-dashboard-refresh">更新</button>
      </div>
      <div class="note" id="ops-dashboard-note"></div>
      <div class="note" id="ops-dashboard-error"></div>
      <table>
        <thead>
          <tr>
            <th>lineUserId</th>
            <th>memberNumber</th>
            <th>lastDelivery</th>
            <th>lastNoticeSent</th>
            <th>latestDecisionLog</th>
          </tr>
        </thead>
        <tbody id="ops-dashboard-rows"></tbody>
      </table>
    </div>

    <div class="section" id="ops-console-list-section">
      <h2>Ops Console（Phase26 list）</h2>
      <div class="note">運用判断の一覧（READY優先・安定ソート）。</div>
      <div class="note">
        limit: <input type="number" id="ops-console-limit" min="1" max="200" value="20" />
        <button class="btn" id="ops-console-refresh">更新</button>
      </div>
      <div class="note" id="ops-console-list-note"></div>
      <div class="note" id="ops-console-list-error"></div>
      <table>
        <thead>
          <tr>
            <th>lineUserId</th>
            <th>readiness</th>
            <th>recommendedNextAction</th>
            <th>allowedNextActions</th>
            <th>opsState.nextAction</th>
            <th>latestDecisionLog</th>
            <th>LLM suggestion</th>
            <th>詳細</th>
          </tr>
        </thead>
        <tbody id="ops-console-list-rows"></tbody>
      </table>
    </div>

    <div class="section" id="ops-console-detail-section">
      <h2>Ops Console 詳細</h2>
      <div class="note">lineUserId: <span id="ops-console-detail-line-user-id">-</span></div>
      <div class="note" id="ops-console-detail-error"></div>
      <div class="note">traceId: <span id="ops-console-detail-trace-id">-</span> / viewAuditId: <span id="ops-console-detail-view-audit-id">-</span></div>
      <div>
        readiness.status:
        <span id="ops-console-detail-readiness-status">-</span>
        <span id="ops-console-detail-danger-badge" class="badge">-</span>
      </div>
      <div>blockingReasons: <span id="ops-console-detail-blocking-reasons">-</span></div>
      <div>lastReactionAt（LINE定義）: <span id="ops-console-detail-last-reaction-at">-</span></div>
      <div>execution: <span id="ops-console-detail-execution-message">-</span></div>
      <div>latestDecisionSummary:</div>
      <pre id="ops-console-detail-latest-decision-summary">-</pre>
      <div>recommendedNextAction: <span id="ops-console-detail-recommended">-</span></div>
      <div>allowedNextActions: <span id="ops-console-detail-allowed">-</span></div>
      <div>readiness:</div>
      <pre id="ops-console-detail-readiness">-</pre>
      <div>opsState:</div>
      <pre id="ops-console-detail-ops-state">-</pre>
      <div>latestDecisionLog:</div>
      <pre id="ops-console-detail-latest-decision">-</pre>
      <div>userStateSummary:</div>
      <pre id="ops-console-detail-user-summary">-</pre>
      <div>memberSummary:</div>
      <pre id="ops-console-detail-member-summary">-</pre>
      <div>llmSuggestion:</div>
      <pre id="ops-console-detail-llm-suggestion">-</pre>
      <div>suggestion(schema):</div>
      <pre id="ops-console-detail-suggestion-schema">-</pre>
      <div>lastSuggestionAuditId: <span id="ops-console-detail-suggestion-audit-id">-</span></div>
      <div>llmSuggestion summary:</div>
      <div>suggestedNextAction: <span id="ops-console-detail-suggested-action">-</span></div>
      <div>safety:</div>
      <pre id="ops-console-detail-safety">-</pre>
      <div>evidence:</div>
      <pre id="ops-console-detail-evidence">-</pre>
      <div>phase39Suggestion:</div>
      <pre id="ops-console-detail-phase39-suggestion">-</pre>
      <div>phase39AuditId: <span id="ops-console-detail-phase39-audit-id">-</span></div>

      <h3>Notification Health（add-only）</h3>
      <div class="note">通知の sent/click/read をSSOT（notification_deliveries）から再計算した read-model に基づく（表示のみ）。</div>
      <div>notificationHealthSummary:</div>
      <pre id="ops-console-detail-notification-health-summary">-</pre>
      <div>topUnhealthyNotifications:</div>
      <pre id="ops-console-detail-top-unhealthy">-</pre>
      <div>mitigationSuggestion（advisory）:</div>
      <pre id="ops-console-detail-mitigation-suggestion">-</pre>

      <h3>Ops Decision Submit</h3>
      <div class="note">allowedNextActions のみ選択可。</div>
      <div class="note">
        nextAction:
        <select id="ops-decision-action"></select>
        failure_class:
        <select id="ops-decision-failure-class">
          <option value="PASS">PASS</option>
          <option value="ENV">ENV</option>
          <option value="IMPL">IMPL</option>
          <option value="CONFIG">CONFIG</option>
          <option value="UNKNOWN" selected>UNKNOWN</option>
        </select>
      </div>
      <div class="note">
        reasonCode: <input type="text" id="ops-decision-reason-code" />
        stage: <input type="text" id="ops-decision-stage" />
      </div>
      <div class="note">
        note: <input type="text" id="ops-decision-note" />
        <button class="btn" id="ops-decision-submit">submit</button>
      </div>
      <div class="note">
        <button class="btn" id="ops-decision-use-suggestion">Use Suggestion</button>
        <span id="ops-decision-use-suggestion-note"></span>
      </div>
      <div class="note">
        notification mitigation decision（advisory）:
        <select id="ops-mitigation-decision">
          <option value="">(no record)</option>
          <option value="SKIP">SKIP</option>
          <option value="ADOPT">ADOPT</option>
          <option value="REJECT">REJECT</option>
        </select>
        note: <input type="text" id="ops-mitigation-note" />
      </div>
      <pre id="ops-decision-result">-</pre>
    </div>

    <div class="section" id="segment-send-section">
      <h2>Segment Send（Plan / Execute）</h2>
      <div class="note">Plan/Execute は人間操作。送信自体は Phase68 のガードに従う。</div>
      <div class="note">
        templateKey:
        <input type="text" id="segment-template-key" />
        templateVersion:
        <input type="number" id="segment-template-version" min="1" />
        savedSegment:
        <select id="saved-segment-select"></select>
        readiness:
        <select id="segment-readiness">
          <option value="">ALL</option>
          <option value="READY">READY</option>
          <option value="NOT_READY">NOT_READY</option>
        </select>
        needsAttention:
        <input type="checkbox" id="segment-needs-attention" />
        limit:
        <input type="number" id="segment-limit" min="1" max="200" value="50" />
        <button class="btn" id="segment-plan">Plan</button>
        <button class="btn" id="segment-dryrun">Dry-run</button>
        <button class="btn" id="segment-execute">Execute</button>
      </div>
      <div class="note" id="segment-plan-note"></div>
      <pre id="segment-plan-result">-</pre>
      <div class="note" id="segment-dryrun-note"></div>
      <pre id="segment-dryrun-result">-</pre>
      <div class="note" id="segment-execute-note"></div>
      <pre id="segment-execute-result">-</pre>
    </div>

    <div class="section" id="retry-queue-section">
      <h2>Send Retry Queue（READ ONLY + Manual Retry）</h2>
      <div class="note">PENDING の再送キュー一覧。手動で retry する。</div>
      <div class="note">
        limit:
        <input type="number" id="retry-queue-limit" min="1" max="200" value="50" />
        <button class="btn" id="retry-queue-refresh">更新</button>
      </div>
      <div class="note" id="retry-queue-note"></div>
      <div class="note" id="retry-queue-error"></div>
      <table>
        <thead>
          <tr>
            <th>queueId</th>
            <th>lineUserId</th>
            <th>templateKey</th>
            <th>status</th>
            <th>lastError</th>
            <th>updatedAt</th>
            <th>操作</th>
          </tr>
        </thead>
        <tbody id="retry-queue-rows"></tbody>
      </table>
    </div>

    <div class="section">
      <h2>memberNumber 未入力（14日超）</h2>
      <div class="note" id="member-stale-count"></div>
      <table>
        <thead>
          <tr>
            <th>lineUserId</th>
            <th>createdAt</th>
            <th>daysSinceCreated</th>
          </tr>
        </thead>
        <tbody id="member-stale-rows"></tbody>
      </table>
    </div>

    <div class="section">
      <h2>Last reviewed</h2>
      <div class="note">手動入力のみ（閲覧や集計では更新しない）</div>
      <div>At: <span id="ops-review-at">-</span></div>
      <div>By: <span id="ops-review-by">-</span></div>
    </div>

    <div class="section" id="implementation-targets">
      <h2>Implementation Targets</h2>
      <div class="note">READ ONLY（参照のみ）</div>
      <table>
        <thead>
          <tr>
            <th>id</th>
            <th>name</th>
            <th>tag</th>
            <th>status</th>
          </tr>
        </thead>
        <tbody id="implementation-targets-rows"></tbody>
      </table>
    </div>

    <script>
      let opsConsoleListCache = [];
      let opsConsoleDetailCache = null;
      let opsConsoleAssistCache = {};
      let selectedOpsConsoleLineUserId = null;
      let selectedOpsConsoleTraceId = null;
      let lastOpsSuggestion = null;
      let lastSuggestionUsed = false;
      let lastMitigationSuggestion = null;
      let lastTopUnhealthyNotifications = [];
      let segmentSendPlanCache = null;
      let segmentSendDryRunCache = null;
      let retryQueueCache = [];
      let savedSegmentsCache = [];
      let selectedSegmentCache = null;

      function clearChildren(node) {
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
      }

      function setText(node, value) {
        if (!node) return;
        node.textContent = value === undefined || value === null ? '-' : String(value);
      }

      function formatJson(value) {
        if (value === undefined || value === null) return '-';
        return JSON.stringify(value, null, 2);
      }

      function formatSuggestionShort(suggestion) {
        if (!suggestion) return '-';
        if (suggestion.suggestion && suggestion.suggestion.recommendedNextAction) {
          const reason = suggestion.suggestion.reason ? `: ${suggestion.suggestion.reason}` : '';
          return `${suggestion.suggestion.recommendedNextAction}${reason}`;
        }
        if (suggestion.suggestion && suggestion.suggestion.nextAction) {
          const reason = suggestion.suggestion.reason ? `: ${suggestion.suggestion.reason}` : '';
          return `${suggestion.suggestion.nextAction}${reason}`;
        }
        if (typeof suggestion.suggestionText === 'string') return suggestion.suggestionText;
        return '-';
      }

      function extractSuggestedAction(suggestion) {
        if (!suggestion) return null;
        if (suggestion.suggestion && suggestion.suggestion.recommendedNextAction) {
          return suggestion.suggestion.recommendedNextAction;
        }
        if (suggestion.suggestion && suggestion.suggestion.nextAction) {
          return suggestion.suggestion.nextAction;
        }
        if (typeof suggestion.recommendedNextAction === 'string') return suggestion.recommendedNextAction;
        return null;
      }

      function buildRangeQuery(prefix) {
        const from = document.getElementById(`${prefix}-from`).value;
        const to = document.getElementById(`${prefix}-to`).value;
        const params = new URLSearchParams();
        if (from) params.set('from', from);
        if (to) params.set('to', to);
        const qs = params.toString();
        return qs ? `?${qs}` : '';
      }

      function buildUsersQuery() {
        const params = new URLSearchParams();
        const from = document.getElementById('users-from').value;
        const to = document.getElementById('users-to').value;
        if (from) params.set('from', from);
        if (to) params.set('to', to);

        if (document.getElementById('filter-needsAttention').checked) {
          params.set('needsAttention', '1');
        }
        if (document.getElementById('filter-stale').checked) {
          params.set('stale', '1');
        }
        if (document.getElementById('filter-unreviewed').checked) {
          params.set('unreviewed', '1');
        }
        const reviewAgeDays = document.getElementById('filter-reviewAgeDays').value;
        if (reviewAgeDays) {
          params.set('reviewAgeDays', reviewAgeDays);
        }

        const qs = params.toString();
        return qs ? `?${qs}` : '';
      }

      function hydrateUsersFilters() {
        const params = new URLSearchParams(location.search);
        const from = params.get('from');
        const to = params.get('to');
        if (from) document.getElementById('users-from').value = from;
        if (to) document.getElementById('users-to').value = to;

        document.getElementById('filter-needsAttention').checked = params.get('needsAttention') === '1';
        document.getElementById('filter-stale').checked = params.get('stale') === '1';
        document.getElementById('filter-unreviewed').checked = params.get('unreviewed') === '1';
        const reviewAgeDays = params.get('reviewAgeDays');
        if (reviewAgeDays) document.getElementById('filter-reviewAgeDays').value = reviewAgeDays;
      }

      function syncUsersQueryToUrl() {
        const params = new URLSearchParams(location.search);
        const from = document.getElementById('users-from').value;
        const to = document.getElementById('users-to').value;
        if (from) params.set('from', from); else params.delete('from');
        if (to) params.set('to', to); else params.delete('to');
        const lineUserId = params.get('lineUserId');
        if (lineUserId) params.set('lineUserId', lineUserId);

        const needsAttention = document.getElementById('filter-needsAttention').checked;
        const stale = document.getElementById('filter-stale').checked;
        const unreviewed = document.getElementById('filter-unreviewed').checked;
        const reviewAgeDays = document.getElementById('filter-reviewAgeDays').value;

        if (needsAttention) params.set('needsAttention', '1'); else params.delete('needsAttention');
        if (stale) params.set('stale', '1'); else params.delete('stale');
        if (unreviewed) params.set('unreviewed', '1'); else params.delete('unreviewed');
        if (reviewAgeDays) params.set('reviewAgeDays', reviewAgeDays); else params.delete('reviewAgeDays');

        const qs = params.toString();
        const nextUrl = qs ? `${location.pathname}?${qs}` : location.pathname;
        history.replaceState(null, '', nextUrl);
      }

      async function loadUsers() {
        const res = await fetch(`/api/phase5/ops/users-summary${buildUsersQuery()}`);
        const data = await res.json();
        const rows = document.getElementById('users-rows');
        const note = document.getElementById('user-summary-note');
        renderReview(data.review);
        if (!data.ok) {
          rows.innerHTML = '<tr><td colspan="9">error</td></tr>';
          return;
        }
        if (!data.items.length) {
          rows.innerHTML = '<tr><td colspan="9">no data</td></tr>';
          return;
        }
        rows.innerHTML = data.items.map((item) => `
          <tr>
            <td>${item.lineUserId}</td>
            <td>${item.hasMemberNumber ? 'あり' : 'なし'}</td>
            <td>${item.checklistCompleted}/${item.checklistTotal}</td>
            <td>${item.stale ? 'Yes' : 'No'}</td>
            <td>${item.needsAttention ? 'Yes' : 'No'}</td>
            <td>${item.opsReviewLastReviewedAt || '-'}</td>
            <td>${item.opsReviewLastReviewedBy || '-'}</td>
            <td>${item.lastActionAt || '-'}</td>
            <td><button class="btn" data-review="${item.lineUserId}">Reviewed</button></td>
          </tr>
        `).join('');

        rows.querySelectorAll('button[data-review]').forEach((btn) => {
          btn.addEventListener('click', async (event) => {
            const lineUserId = event.currentTarget.getAttribute('data-review');
            if (!lineUserId) return;
            await fetch('/api/phase5/admin/users/review', {
              method: 'POST',
              headers: { 'content-type': 'application/json; charset=utf-8' },
              body: JSON.stringify({ lineUserId })
            });
            await loadUsers();
          });
        });

        const params = new URLSearchParams(location.search);
        const lineUserId = params.get('lineUserId');
        if (!lineUserId) {
          note.textContent = 'lineUserId を指定すると個別の状態サマリを表示します';
          return;
        }
        const summaryRes = await fetch(`/api/phase5/state/summary?lineUserId=${encodeURIComponent(lineUserId)}`);
        const summary = await summaryRes.json();
        if (summary.ok && summary.item) {
          const item = summary.item;
          note.textContent = `summary: ${item.lineUserId} / memberNumber: ${item.hasMemberNumber ? 'あり' : 'なし'} / checklist: ${item.checklistCompleted}/${item.checklistTotal} / lastActionAt: ${item.lastActionAt || '-'}`;
        } else {
          note.textContent = 'summary: unavailable';
        }
      }

      async function loadNotifications() {
        const res = await fetch(`/api/phase5/ops/notifications-summary${buildRangeQuery('notifications')}`);
        const data = await res.json();
        const rows = document.getElementById('notifications-rows');
        if (!data.ok) {
          rows.innerHTML = '<tr><td colspan="6">error</td></tr>';
          return;
        }
        if (!data.items.length) {
          rows.innerHTML = '<tr><td colspan="6">no data</td></tr>';
          return;
        }
        rows.innerHTML = data.items.map((item) => `
          <tr>
            <td>${item.notificationId}</td>
            <td>${item.sentAt || '-'}</td>
            <td>${item.openCount}</td>
            <td>${item.clickCount}</td>
            <td>${item.lastReactionAt || '-'}</td>
            <td><button class="btn" disabled>詳細を見る</button></td>
          </tr>
        `).join('');
      }

      function renderOpsDashboard(items) {
        const rows = document.getElementById('ops-dashboard-rows');
        clearChildren(rows);
        if (!items || !items.length) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 5;
          td.textContent = 'no data';
          tr.appendChild(td);
          rows.appendChild(tr);
          return;
        }
        items.forEach((item) => {
          const tr = document.createElement('tr');
          const cells = [
            item.lineUserId,
            item.memberNumber || '-',
            item.lastDelivery ? JSON.stringify(item.lastDelivery) : '-',
            item.lastNoticeSent ? JSON.stringify(item.lastNoticeSent) : '-',
            item.latestDecisionLog ? JSON.stringify(item.latestDecisionLog) : '-'
          ];
          cells.forEach((value) => {
            const td = document.createElement('td');
            td.textContent = value;
            tr.appendChild(td);
          });
          rows.appendChild(tr);
        });
      }

      async function loadOpsDashboard() {
        const note = document.getElementById('ops-dashboard-note');
        const errorEl = document.getElementById('ops-dashboard-error');
        setText(errorEl, '');
        const limitValue = document.getElementById('ops-dashboard-limit').value;
        const limit = limitValue ? Number(limitValue) : 20;
        try {
          const data = await fetchOpsDashboard(limit);
          if (!data || !data.ok) {
            setText(errorEl, 'error');
            renderOpsDashboard([]);
            return;
          }
          setText(note, `serverTime: ${data.serverTime || '-'}`);
          renderOpsDashboard(Array.isArray(data.items) ? data.items : []);
        } catch (err) {
          setText(errorEl, 'error');
          renderOpsDashboard([]);
        }
      }

      async function loadStaleMemberNumber() {
        const res = await fetch('/api/phase5/ops/member-number-stale');
        const data = await res.json();
        const countEl = document.getElementById('member-stale-count');
        const rows = document.getElementById('member-stale-rows');
        if (!data.ok) {
          countEl.textContent = 'error';
          rows.innerHTML = '<tr><td colspan="3">error</td></tr>';
          return;
        }
        countEl.textContent = `count: ${data.count}`;
        if (!data.items.length) {
          rows.innerHTML = '<tr><td colspan="3">none</td></tr>';
          return;
        }
        rows.innerHTML = data.items.map((item) => `
          <tr>
            <td>${item.lineUserId}</td>
            <td>${item.createdAt || '-'}</td>
            <td>${item.daysSinceCreated}</td>
          </tr>
        `).join('');
      }

      function renderReview(review) {
        const atEl = document.getElementById('ops-review-at');
        const byEl = document.getElementById('ops-review-by');
        if (!atEl || !byEl) return;
        if (!review || !review.lastReviewedAt || !review.lastReviewedBy) {
          atEl.textContent = '-';
          byEl.textContent = '-';
          return;
        }
        atEl.textContent = review.lastReviewedAt;
        byEl.textContent = review.lastReviewedBy;
      }

      async function loadImplementationTargets() {
        const res = await fetch('/admin/implementation-targets');
        const rows = document.getElementById('implementation-targets-rows');
        const data = await res.json();
        if (!Array.isArray(data)) {
          rows.innerHTML = '<tr><td colspan="4">error</td></tr>';
          return;
        }
        if (!data.length) {
          rows.innerHTML = '<tr><td colspan="4">no data</td></tr>';
          return;
        }
        rows.innerHTML = data.map((item) => `
          <tr>
            <td>${item.id}</td>
            <td>${item.name || '-'}</td>
            <td>${item.tag || '-'}</td>
            <td>${item.status || '-'}</td>
          </tr>
        `).join('');
      }

      const OPS_ACTOR_HEADERS = { 'x-actor': 'ops_readonly' };

      async function fetchOpsConsoleList(limit) {
        const params = new URLSearchParams();
        if (limit) params.set('limit', String(limit));
        const qs = params.toString();
        const res = await fetch(`/api/phase26/ops-console/list${qs ? `?${qs}` : ''}`);
        return res.json();
      }

      async function fetchOpsConsoleDetail(lineUserId) {
        const res = await fetch(`/api/phase25/ops/console?lineUserId=${encodeURIComponent(lineUserId)}`, {
          headers: OPS_ACTOR_HEADERS
        });
        return res.json();
      }

      async function fetchOpsDashboard(limit) {
        const params = new URLSearchParams();
        if (limit) params.set('limit', String(limit));
        const qs = params.toString();
        const res = await fetch(`/api/phase38/ops/dashboard${qs ? `?${qs}` : ''}`);
        return res.json();
      }

      async function fetchOpsAssistDetail(lineUserId) {
        const res = await fetch(`/api/phase42/ops-console/view?lineUserId=${encodeURIComponent(lineUserId)}&includeAssist=1`);
        return res.json();
      }

      async function fetchPhase39Suggestion(lineUserId) {
        const res = await fetch(`/api/phase39/ops-assist/suggestion?lineUserId=${encodeURIComponent(lineUserId)}`);
        return res.json();
      }

      async function submitOpsDecisionRequest(payload) {
        const res = await fetch('/api/phase25/ops/decision', {
          method: 'POST',
          headers: Object.assign({ 'content-type': 'application/json; charset=utf-8' }, OPS_ACTOR_HEADERS),
          body: JSON.stringify(payload)
        });
        return res.json();
      }

      async function fetchTraceBundle(traceId, limit) {
        const params = new URLSearchParams();
        params.set('traceId', traceId);
        if (limit) params.set('limit', String(limit));
        const res = await fetch(`/api/admin/trace?${params.toString()}`, { headers: OPS_ACTOR_HEADERS });
        return res.json();
      }

      async function submitOpsAssistAdopt(payload) {
        const res = await fetch('/api/phase105/ops-assist/adopt', {
          method: 'POST',
          headers: { 'content-type': 'application/json; charset=utf-8' },
          body: JSON.stringify(payload)
        });
        return res.json();
      }

      async function fetchSegmentPlan(payload) {
        const res = await fetch('/api/phase67/send/plan', {
          method: 'POST',
          headers: { 'content-type': 'application/json; charset=utf-8' },
          body: JSON.stringify(payload)
        });
        return res.json();
      }

      async function fetchSegmentExecute(payload) {
        const res = await fetch('/api/phase68/send/execute', {
          method: 'POST',
          headers: { 'content-type': 'application/json; charset=utf-8' },
          body: JSON.stringify(payload)
        });
        return res.json();
      }

      async function fetchSegmentDryRun(payload) {
        const res = await fetch('/api/phase81/segment-send/dry-run', {
          method: 'POST',
          headers: { 'content-type': 'application/json; charset=utf-8' },
          body: JSON.stringify(payload)
        });
        return res.json();
      }

      async function fetchRetryQueue(limit) {
        const params = new URLSearchParams();
        if (limit) params.set('limit', String(limit));
        const qs = params.toString();
        const res = await fetch(`/api/phase73/retry-queue${qs ? `?${qs}` : ''}`);
        return res.json();
      }

      async function fetchSavedSegments() {
        const res = await fetch('/api/phase77/segments?status=active');
        return res.json();
      }

      async function retryQueueSend(payload) {
        const res = await fetch('/api/phase73/retry-queue/retry', {
          method: 'POST',
          headers: { 'content-type': 'application/json; charset=utf-8' },
          body: JSON.stringify(payload)
        });
        return res.json();
      }

      function renderOpsConsoleList(items) {
        const rows = document.getElementById('ops-console-list-rows');
        clearChildren(rows);
        if (!items.length) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 8;
          td.textContent = 'no data';
          tr.appendChild(td);
          rows.appendChild(tr);
          return;
        }
        items.forEach((item) => {
          const tr = document.createElement('tr');
          const cells = [
            item.lineUserId,
            item.readiness && item.readiness.status ? item.readiness.status : '-',
            item.recommendedNextAction || '-',
            Array.isArray(item.allowedNextActions) ? item.allowedNextActions.join(', ') : '-',
            item.opsState && item.opsState.nextAction ? item.opsState.nextAction : '-',
            item.latestDecisionLog ? JSON.stringify(item.latestDecisionLog) : '-'
          ];
          cells.forEach((value) => {
            const td = document.createElement('td');
            td.textContent = value;
            tr.appendChild(td);
          });
          const suggestionTd = document.createElement('td');
          suggestionTd.textContent = '-';
          tr.appendChild(suggestionTd);
          loadOpsAssistSummaryForRow(item.lineUserId, suggestionTd).catch(() => {});
          const actionTd = document.createElement('td');
          const btn = document.createElement('button');
          btn.className = 'btn';
          btn.textContent = '詳細';
          btn.dataset.lineUserId = item.lineUserId;
          btn.addEventListener('click', async (event) => {
            const targetId = event.currentTarget.dataset.lineUserId;
            if (!targetId) return;
            await loadOpsConsoleDetail(targetId);
          });
          actionTd.appendChild(btn);
          tr.appendChild(actionTd);
          rows.appendChild(tr);
        });
      }

      function updateDecisionActionOptions(detail) {
        const select = document.getElementById('ops-decision-action');
        clearChildren(select);
        const readinessStatus = detail && detail.readiness ? detail.readiness.status : null;
        let allowed = Array.isArray(detail && detail.allowedNextActions) ? detail.allowedNextActions.slice() : [];
        if (readinessStatus === 'NOT_READY') {
          allowed = ['STOP_AND_ESCALATE'];
        }
        if (!allowed.length) {
          allowed = ['STOP_AND_ESCALATE'];
        }
        allowed.forEach((action) => {
          const option = document.createElement('option');
          option.value = action;
          option.textContent = action;
          select.appendChild(option);
        });
        if (detail && detail.recommendedNextAction && allowed.includes(detail.recommendedNextAction)) {
          select.value = detail.recommendedNextAction;
        }
      }

      function renderOpsConsoleDetail(detail) {
        setText(document.getElementById('ops-console-detail-line-user-id'), detail.lineUserId || '-');
        selectedOpsConsoleTraceId = detail.traceId || null;
        setText(document.getElementById('ops-console-detail-trace-id'), detail.traceId || '-');
        setText(document.getElementById('ops-console-detail-view-audit-id'), detail.viewAuditId || '-');
        setText(document.getElementById('ops-console-detail-readiness-status'), detail.readinessStatus || '-');
        setText(
          document.getElementById('ops-console-detail-blocking-reasons'),
          Array.isArray(detail.blockingReasons) && detail.blockingReasons.length ? detail.blockingReasons.join(', ') : '-'
        );
        setText(document.getElementById('ops-console-detail-last-reaction-at'), detail.lastReactionAt || '-');
        setText(document.getElementById('ops-console-detail-execution-message'), detail.executionMessage || '-');
        setText(document.getElementById('ops-console-detail-latest-decision-summary'), formatJson(detail.latestDecisionSummary));
        const badge = document.getElementById('ops-console-detail-danger-badge');
        if (badge) {
          badge.className = 'badge';
          if (detail && detail.dangerFlags && detail.dangerFlags.notReady) {
            badge.classList.add('badge-danger');
            badge.textContent = 'DANGER: NOT_READY';
          } else if (detail && detail.dangerFlags && detail.dangerFlags.staleMemberNumber) {
            badge.classList.add('badge-warn');
            badge.textContent = 'WARN: stale';
          } else {
            badge.classList.add('badge-ok');
            badge.textContent = 'OK';
          }
        }
        setText(document.getElementById('ops-console-detail-recommended'), detail.recommendedNextAction || '-');
        setText(
          document.getElementById('ops-console-detail-allowed'),
          Array.isArray(detail.allowedNextActions) ? detail.allowedNextActions.join(', ') : '-'
        );
        setText(document.getElementById('ops-console-detail-readiness'), formatJson(detail.readiness));
        setText(document.getElementById('ops-console-detail-ops-state'), formatJson(detail.opsState));
        setText(document.getElementById('ops-console-detail-latest-decision'), formatJson(detail.latestDecisionLog));
        setText(document.getElementById('ops-console-detail-user-summary'), formatJson(detail.userStateSummary));
        setText(document.getElementById('ops-console-detail-member-summary'), formatJson(detail.memberSummary));
        setText(
          document.getElementById('ops-console-detail-notification-health-summary'),
          formatJson(detail.notificationHealthSummary || null)
        );
        setText(
          document.getElementById('ops-console-detail-top-unhealthy'),
          formatJson(detail.topUnhealthyNotifications || [])
        );
        setText(
          document.getElementById('ops-console-detail-mitigation-suggestion'),
          formatJson(detail.mitigationSuggestion || null)
        );
        lastMitigationSuggestion = detail.mitigationSuggestion || null;
        lastTopUnhealthyNotifications = Array.isArray(detail.topUnhealthyNotifications) ? detail.topUnhealthyNotifications : [];
        updateDecisionActionOptions(detail);
      }

      function renderOpsAssistDetail(assist) {
        const suggestion = assist ? assist.llmSuggestion : null;
        setText(document.getElementById('ops-console-detail-llm-suggestion'), formatJson(suggestion));
        setText(
          document.getElementById('ops-console-detail-suggestion-schema'),
          formatJson(assist ? assist.suggestion : null)
        );
        setText(
          document.getElementById('ops-console-detail-suggestion-audit-id'),
          assist && assist.lastSuggestionAuditId ? assist.lastSuggestionAuditId : '-'
        );
        setText(document.getElementById('ops-console-detail-suggested-action'), extractSuggestedAction(suggestion));
        setText(document.getElementById('ops-console-detail-safety'), formatJson(suggestion ? suggestion.safety : null));
        setText(document.getElementById('ops-console-detail-evidence'), formatJson(suggestion ? suggestion.evidence : null));
        lastOpsSuggestion = suggestion;
        lastSuggestionUsed = false;
        setText(document.getElementById('ops-decision-use-suggestion-note'), '');
      }

      function renderSavedSegments(items) {
        const select = document.getElementById('saved-segment-select');
        clearChildren(select);
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'manual';
        select.appendChild(defaultOption);
        if (!items.length) return;
        items.forEach((item) => {
          const option = document.createElement('option');
          option.value = item.segmentKey;
          option.textContent = item.label ? `${item.label} (${item.segmentKey})` : item.segmentKey;
          select.appendChild(option);
        });
      }

      function applySegmentFilter(filter) {
        const readinessEl = document.getElementById('segment-readiness');
        const needsAttentionEl = document.getElementById('segment-needs-attention');
        const limitEl = document.getElementById('segment-limit');
        if (!filter || typeof filter !== 'object') {
          readinessEl.value = '';
          needsAttentionEl.checked = false;
          limitEl.value = 50;
          return;
        }
        readinessEl.value = filter.readinessStatus || '';
        needsAttentionEl.checked = Boolean(filter.needsAttention);
        if (filter.limit) {
          limitEl.value = Number(filter.limit);
        }
      }

      function buildSegmentQueryFromInputs() {
        const readiness = document.getElementById('segment-readiness').value;
        const needsAttention = document.getElementById('segment-needs-attention').checked;
        const limitValue = document.getElementById('segment-limit').value;
        const limit = limitValue ? Number(limitValue) : null;
        const query = {};
        if (readiness) query.readinessStatus = readiness;
        if (needsAttention) query.needsAttention = 1;
        if (limit) query.limit = limit;
        return query;
      }

      function renderSegmentPlanResult(result) {
        const note = document.getElementById('segment-plan-note');
        const resultEl = document.getElementById('segment-plan-result');
        if (!result || !result.ok) {
          setText(note, 'plan error');
          setText(resultEl, formatJson(result || {}));
          return;
        }
        const sample = Array.isArray(result.lineUserIds) ? result.lineUserIds.slice(0, 5).join(', ') : '-';
        setText(note, `count: ${result.count} / planHash: ${result.planHash || '-'} / sample: ${sample}`);
        setText(resultEl, formatJson(result));
      }

      function renderSegmentDryRunResult(result) {
        const note = document.getElementById('segment-dryrun-note');
        const resultEl = document.getElementById('segment-dryrun-result');
        if (!result || !result.ok) {
          setText(note, 'dry-run error');
          setText(resultEl, formatJson(result || {}));
          return;
        }
        const sample = Array.isArray(result.targetsSample) ? result.targetsSample.join(', ') : '-';
        setText(note, `targetCount: ${result.targetCount} / confirmToken: ${result.confirmToken || '-'} / sample: ${sample}`);
        setText(resultEl, formatJson(result));
      }

      function renderSegmentExecuteResult(result) {
        const note = document.getElementById('segment-execute-note');
        const resultEl = document.getElementById('segment-execute-result');
        if (!result) {
          setText(note, 'execute error');
          setText(resultEl, '-');
          return;
        }
        const status = result.ok ? 'ok' : 'error';
        const failureCount = Array.isArray(result.failures) ? result.failures.length : 0;
        setText(note, `result: ${status} / executedCount: ${result.executedCount || 0} / failures: ${failureCount}`);
        setText(resultEl, formatJson(result));
      }

      function renderRetryQueue(items) {
        const rows = document.getElementById('retry-queue-rows');
        clearChildren(rows);
        if (!items.length) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 7;
          td.textContent = 'no data';
          tr.appendChild(td);
          rows.appendChild(tr);
          return;
        }
        items.forEach((item) => {
          const tr = document.createElement('tr');
          const cells = [
            item.id || '-',
            item.lineUserId || '-',
            item.templateKey || '-',
            item.status || '-',
            item.lastError || '-',
            item.updatedAt || item.createdAt || '-'
          ];
          cells.forEach((value) => {
            const td = document.createElement('td');
            td.textContent = value;
            tr.appendChild(td);
          });
          const actionTd = document.createElement('td');
          const btn = document.createElement('button');
          btn.className = 'btn';
          btn.textContent = 'retry';
          btn.dataset.queueId = item.id;
          btn.addEventListener('click', async (event) => {
            const queueId = event.currentTarget.dataset.queueId;
            if (!queueId) return;
            await retryQueueSend({ queueId, decidedBy: 'ops_readonly' });
            await loadRetryQueue();
          });
          actionTd.appendChild(btn);
          tr.appendChild(actionTd);
          rows.appendChild(tr);
        });
      }

      async function loadOpsConsoleList() {
        const note = document.getElementById('ops-console-list-note');
        const errorEl = document.getElementById('ops-console-list-error');
        setText(errorEl, '');
        const limitValue = document.getElementById('ops-console-limit').value;
        const limit = limitValue ? Number(limitValue) : 20;
        try {
          const data = await fetchOpsConsoleList(limit);
          if (!data || !data.ok) {
            setText(errorEl, 'error');
            renderOpsConsoleList([]);
            return;
          }
          opsConsoleListCache = Array.isArray(data.items) ? data.items : [];
          const pageInfoText = data.pageInfo ? JSON.stringify(data.pageInfo) : '-';
          note.textContent = `serverTime: ${data.serverTime || '-'} / pageInfo: ${pageInfoText} / nextPageToken: ${data.nextPageToken || '-'}`;
          renderOpsConsoleList(opsConsoleListCache);
        } catch (err) {
          setText(errorEl, 'error');
          renderOpsConsoleList([]);
        }
      }

      async function loadOpsConsoleDetail(lineUserId) {
        const errorEl = document.getElementById('ops-console-detail-error');
        setText(errorEl, '');
        selectedOpsConsoleLineUserId = lineUserId;
        setText(document.getElementById('ops-console-detail-line-user-id'), lineUserId || '-');
        try {
          const detail = await fetchOpsConsoleDetail(lineUserId);
          if (!detail || !detail.ok) {
            setText(errorEl, 'error');
            return;
          }
          opsConsoleDetailCache = detail;
          renderOpsConsoleDetail(detail);
          await loadOpsAssistDetail(lineUserId);
          await loadPhase39Suggestion(lineUserId);
        } catch (err) {
          setText(errorEl, 'error');
        }
      }

      async function loadOpsAssistDetail(lineUserId) {
        if (!lineUserId) return;
        try {
          const detail = await fetchOpsAssistDetail(lineUserId);
          if (!detail || !detail.ok) {
            renderOpsAssistDetail(null);
            return;
          }
          opsConsoleAssistCache[lineUserId] = detail;
          renderOpsAssistDetail(detail);
        } catch (err) {
          renderOpsAssistDetail(null);
        }
      }

      async function loadOpsAssistSummaryForRow(lineUserId, cell) {
        if (!lineUserId || !cell) return;
        if (opsConsoleAssistCache[lineUserId]) {
          cell.textContent = formatSuggestionShort(opsConsoleAssistCache[lineUserId].llmSuggestion);
          return;
        }
        const detail = await fetchOpsAssistDetail(lineUserId);
        if (detail && detail.ok) {
          opsConsoleAssistCache[lineUserId] = detail;
          cell.textContent = formatSuggestionShort(detail.llmSuggestion);
          return;
        }
        cell.textContent = '-';
      }

      async function loadPhase39Suggestion(lineUserId) {
        if (!lineUserId) return;
        try {
          const detail = await fetchPhase39Suggestion(lineUserId);
          if (!detail || !detail.ok) {
            setText(document.getElementById('ops-console-detail-phase39-suggestion'), '-');
            setText(document.getElementById('ops-console-detail-phase39-audit-id'), '-');
            return;
          }
          setText(
            document.getElementById('ops-console-detail-phase39-suggestion'),
            formatJson(detail.suggestion)
          );
          setText(
            document.getElementById('ops-console-detail-phase39-audit-id'),
            detail.auditId || '-'
          );
        } catch (err) {
          setText(document.getElementById('ops-console-detail-phase39-suggestion'), '-');
          setText(document.getElementById('ops-console-detail-phase39-audit-id'), '-');
        }
      }

      async function handleSegmentPlan() {
        const note = document.getElementById('segment-plan-note');
        setText(note, '');
        segmentSendPlanCache = null;
        segmentSendDryRunCache = null;
        const templateKey = document.getElementById('segment-template-key').value.trim();
        const templateVersionValue = document.getElementById('segment-template-version').value;
        const templateVersion = templateVersionValue ? Number(templateVersionValue) : null;
        if (!templateKey) {
          setText(note, 'templateKey required');
          return;
        }
        const segmentQuery = buildSegmentQueryFromInputs();
        const segmentKey = selectedSegmentCache ? selectedSegmentCache.segmentKey : null;
        const filterSnapshot = selectedSegmentCache ? selectedSegmentCache.filter : null;
        const payload = {
          templateKey,
          templateVersion,
          segmentQuery,
          segmentKey,
          filterSnapshot,
          requestedBy: 'ops_readonly'
        };
        const result = await fetchSegmentPlan(payload);
        renderSegmentPlanResult(result);
        if (result && result.ok) {
          segmentSendPlanCache = {
            templateKey,
            planHash: result.planHash,
            segmentQuery,
            templateVersion: result.templateVersion || templateVersion,
            segmentKey,
            filterSnapshot
          };
        }
      }

      async function handleSegmentDryRun() {
        const note = document.getElementById('segment-dryrun-note');
        setText(note, '');
        segmentSendDryRunCache = null;
        const templateKey = document.getElementById('segment-template-key').value.trim();
        const templateVersionValue = document.getElementById('segment-template-version').value;
        const templateVersion = templateVersionValue ? Number(templateVersionValue) : null;
        if (!templateKey) {
          setText(note, 'templateKey required');
          return;
        }
        const segmentQuery = buildSegmentQueryFromInputs();
        const segmentKey = selectedSegmentCache ? selectedSegmentCache.segmentKey : null;
        const filterSnapshot = selectedSegmentCache ? selectedSegmentCache.filter : null;
        const payload = {
          templateKey,
          templateVersion,
          segmentQuery,
          segmentKey,
          filterSnapshot,
          requestedBy: 'ops_readonly'
        };
        const result = await fetchSegmentDryRun(payload);
        renderSegmentDryRunResult(result);
        if (result && result.ok) {
          segmentSendDryRunCache = {
            confirmToken: result.confirmToken,
            planHash: result.planHash
          };
        }
      }

      async function handleSegmentExecute() {
        const note = document.getElementById('segment-execute-note');
        setText(note, '');
        const templateKey = document.getElementById('segment-template-key').value.trim();
        if (!templateKey) {
          setText(note, 'templateKey required');
          return;
        }
        if (!segmentSendPlanCache || !segmentSendPlanCache.planHash) {
          setText(note, 'plan required');
          return;
        }
        if (!segmentSendDryRunCache || !segmentSendDryRunCache.confirmToken) {
          setText(note, 'confirmToken required (run dry-run)');
          return;
        }
        if (segmentSendPlanCache.templateKey && segmentSendPlanCache.templateKey !== templateKey) {
          setText(note, 'plan/template mismatch');
          return;
        }
        const payload = {
          templateKey,
          segmentQuery: segmentSendPlanCache.segmentQuery || {},
          requestedBy: 'ops_readonly',
          planHash: segmentSendPlanCache.planHash,
          templateVersion: segmentSendPlanCache.templateVersion || null,
          segmentKey: segmentSendPlanCache.segmentKey || null,
          filterSnapshot: segmentSendPlanCache.filterSnapshot || null,
          confirmToken: segmentSendDryRunCache.confirmToken
        };
        const result = await fetchSegmentExecute(payload);
        renderSegmentExecuteResult(result);
        await loadRetryQueue();
      }

      async function loadRetryQueue() {
        const note = document.getElementById('retry-queue-note');
        const errorEl = document.getElementById('retry-queue-error');
        setText(errorEl, '');
        const limitValue = document.getElementById('retry-queue-limit').value;
        const limit = limitValue ? Number(limitValue) : 50;
        try {
          const data = await fetchRetryQueue(limit);
          if (!data || !data.ok) {
            setText(errorEl, 'error');
            renderRetryQueue([]);
            return;
          }
          retryQueueCache = Array.isArray(data.items) ? data.items : [];
          setText(note, `serverTime: ${data.serverTime || '-'}`);
          renderRetryQueue(retryQueueCache);
        } catch (err) {
          setText(errorEl, 'error');
          renderRetryQueue([]);
        }
      }

      async function loadSavedSegments() {
        const select = document.getElementById('saved-segment-select');
        try {
          const data = await fetchSavedSegments();
          if (!data || !data.ok) {
            renderSavedSegments([]);
            return;
          }
          savedSegmentsCache = Array.isArray(data.items) ? data.items : [];
          renderSavedSegments(savedSegmentsCache);
          select.value = '';
          selectedSegmentCache = null;
        } catch (_err) {
          renderSavedSegments([]);
        }
      }

      async function handleSubmitOpsDecision() {
        const resultEl = document.getElementById('ops-decision-result');
        setText(resultEl, '');
        const lineUserId = selectedOpsConsoleLineUserId;
        if (!lineUserId) {
          setText(resultEl, 'lineUserId not selected');
          return;
        }
        const nextAction = document.getElementById('ops-decision-action').value;
        const failureClass = document.getElementById('ops-decision-failure-class').value;
        const reasonCode = document.getElementById('ops-decision-reason-code').value;
        const stage = document.getElementById('ops-decision-stage').value;
        const note = document.getElementById('ops-decision-note').value;
        const mitigationDecisionValue = document.getElementById('ops-mitigation-decision').value;
        const mitigationNote = document.getElementById('ops-mitigation-note').value;
        let notificationMitigationDecision = null;
        if (mitigationDecisionValue) {
          const targetId = lastTopUnhealthyNotifications.length ? lastTopUnhealthyNotifications[0].notificationId : null;
          notificationMitigationDecision = {
            decision: mitigationDecisionValue,
            note: mitigationNote || '',
            actionType: lastMitigationSuggestion ? lastMitigationSuggestion.actionType || null : null,
            targetNotificationId: targetId || null
          };
        }
        const payload = {
          lineUserId,
          traceId: selectedOpsConsoleTraceId,
          decision: {
            nextAction,
            failure_class: failureClass,
            reasonCode: reasonCode || null,
            stage: stage || null,
            note: note || ''
          },
          notificationMitigationDecision
        };
        try {
          const result = await submitOpsDecisionRequest(payload);
          setText(resultEl, formatJson(result));
          if (result && result.ok) {
            if (lastSuggestionUsed) {
              const suggestedAction = extractSuggestedAction(lastOpsSuggestion);
              if (suggestedAction && suggestedAction === nextAction) {
                try {
                  await submitOpsAssistAdopt({
                    lineUserId,
                    decisionLogId: result.decisionLogId || null,
                    adoptedAction: nextAction,
                    suggestion: lastOpsSuggestion ? lastOpsSuggestion.suggestion || null : null,
                    safety: lastOpsSuggestion ? lastOpsSuggestion.safety || null : null
                  });
                } catch (_err) {
                  // best-effort only
                }
              }
            }
            await loadOpsConsoleDetail(lineUserId);
            await loadOpsConsoleList();
          }
        } catch (err) {
          setText(resultEl, 'error');
        }
        lastSuggestionUsed = false;
      }

      async function handleTraceSearch() {
        const traceId = document.getElementById('trace-search-trace-id').value;
        const limitValue = document.getElementById('trace-search-limit').value;
        const limit = limitValue ? Number(limitValue) : 50;
        const resultEl = document.getElementById('trace-search-result');
        setText(resultEl, '');
        if (!traceId || !String(traceId).trim()) {
          setText(resultEl, 'traceId required');
          return;
        }
        try {
          const data = await fetchTraceBundle(String(traceId).trim(), limit);
          setText(resultEl, formatJson(data));
        } catch (_err) {
          setText(resultEl, 'error');
        }
      }

      document.getElementById('users-apply').addEventListener('click', () => {
        syncUsersQueryToUrl();
        loadUsers().catch(() => {});
      });
      document.getElementById('notifications-apply').addEventListener('click', () => {
        loadNotifications().catch(() => {});
      });
      document.getElementById('trace-search-run').addEventListener('click', () => {
        handleTraceSearch().catch(() => {});
      });
      document.getElementById('ops-dashboard-refresh').addEventListener('click', () => {
        loadOpsDashboard().catch(() => {});
      });
      document.getElementById('ops-console-refresh').addEventListener('click', () => {
        loadOpsConsoleList().catch(() => {});
      });
      document.getElementById('ops-decision-submit').addEventListener('click', () => {
        handleSubmitOpsDecision().catch(() => {});
      });
      document.getElementById('ops-decision-use-suggestion').addEventListener('click', () => {
        const noteEl = document.getElementById('ops-decision-use-suggestion-note');
        const action = extractSuggestedAction(lastOpsSuggestion);
        if (!action) {
          setText(noteEl, 'no suggestion');
          lastSuggestionUsed = false;
          return;
        }
        const select = document.getElementById('ops-decision-action');
        if (select) {
          select.value = action;
        }
        lastSuggestionUsed = true;
        setText(noteEl, `selected: ${action}`);
      });
      document.getElementById('segment-plan').addEventListener('click', () => {
        handleSegmentPlan().catch(() => {});
      });
      document.getElementById('segment-dryrun').addEventListener('click', () => {
        handleSegmentDryRun().catch(() => {});
      });
      document.getElementById('segment-execute').addEventListener('click', () => {
        handleSegmentExecute().catch(() => {});
      });
      document.getElementById('retry-queue-refresh').addEventListener('click', () => {
        loadRetryQueue().catch(() => {});
      });
      document.getElementById('saved-segment-select').addEventListener('change', (event) => {
        const key = event.currentTarget.value;
        if (!key) {
          selectedSegmentCache = null;
          return;
        }
        const segment = savedSegmentsCache.find((item) => item.segmentKey === key);
        selectedSegmentCache = segment || null;
        applySegmentFilter(segment ? segment.filter : null);
      });

      hydrateUsersFilters();
      Promise.all([
        loadUsers(),
        loadNotifications(),
        loadOpsDashboard(),
        loadStaleMemberNumber(),
        loadImplementationTargets(),
        loadOpsConsoleList(),
        loadRetryQueue(),
        loadSavedSegments()
      ]).catch(() => {
        document.getElementById('users-rows').innerHTML = '<tr><td colspan="9">error</td></tr>';
        document.getElementById('notifications-rows').innerHTML = '<tr><td colspan="6">error</td></tr>';
        document.getElementById('ops-dashboard-rows').innerHTML = '<tr><td colspan="5">error</td></tr>';
        document.getElementById('member-stale-rows').innerHTML = '<tr><td colspan="3">error</td></tr>';
        document.getElementById('implementation-targets-rows').innerHTML = '<tr><td colspan="4">error</td></tr>';
      });
    </script>
  </body>
</html>
